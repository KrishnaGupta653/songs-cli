#!/usr/bin/env zsh
# ============================================================
#  m â€” terminal music CLI  (hardened build v5 â€” "God Tier")
#  All state lives in ~/music_system/
#
#  v5 changes over v4:
#   v5-A  CRITICAL BUG FIX: _wait_prop now yields 0.3s before polling +
#         retries if title looks like a URL â†’ fixes "unknown" on first play
#   v5-B  CRITICAL BUG FIX: _lock stale-steal no longer rmdir's unowned lock
#   v5-C  CRITICAL BUG FIX: txt bg job PID written atomically BEFORE disown
#   v5-D  _wait_prop: distinguishes "property unavailable" vs "still loading"
#         via _get_checked() â€” no more 60-iteration spin on hard errors
#   v5-E  _clean_url: handles YouTube Shorts (/shorts/ID), SoundCloud,
#         Bandcamp; never calls _clean_url on local files
#   v5-F  do_bar: cursor always restored after loop exit (not just trap)
#   v5-G  do_similar: python3 replaced with jq @uri for URL encoding
#   v5-H  do_export: CSV injection guard (prefix dangerous cells with tab)
#   v5-I  _log_history: rolling dedup â€” won't log same URL within last 50 entries
#   v5-J  _shuf1: reservoir sampling (O(1) memory, no modulo bias)
#   v5-K  do_bar: single jq parse pass (was 9 forks/frame â†’ 1)
#   v5-L  SPEED: YouTube Data API v3 / Invidious search path (curl+jq, ms not s)
#         Falls back to yt-dlp scrape if API key not set or request fails
#   v5-M  SPEED: fzf --bind change:reload for live async search UI
#   v5-N  SPEED: do_txt parallel resolution â€” all lines fetched concurrently
#   v5-O  UI: m art â€” terminal album art via chafa (falls back gracefully)
#   v5-P  UI: m lyrics â€” real-time synced lyrics from lrclib.net
#   v5-Q  UI: m ui â€” unified TUI dashboard (queue + art + bar in tmux/split)
#   v5-R  Auto-DJ / radio mode â€” queue auto-refills from Last.fm when empty
#   v5-S  m add-next â€” insert track immediately after current queue position
#   v5-T  m bookmark â€” named snapshot of queue + position + timestamp
#   v5-U  m txt --resume â€” resume txt playlist from last saved position
#   v5-V  m reload-config â€” hot-reload config without killing daemon
#   v5-W  Graceful EXIT trap â€” always unlocks locks on shell exit
#   v5-X  m index â€” scan ~/Music, build local library cache via ffprobe
#   v5-Y  SponsorBlock note added to help (mpv lua script path documented)
#   v5-Z  PIPESTATUS checks in _pick() and _txt_search_and_play_line()
# ============================================================

set -u

# â”€â”€ paths â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
MUSIC_ROOT="${MUSIC_ROOT:-$HOME/music_system}"
SOCKET_DIR="$MUSIC_ROOT/socket"
SOCKET="$SOCKET_DIR/mpv.sock"
MPV_PID_FILE="$SOCKET_DIR/mpv.pid"
CACHE_DIR="$MUSIC_ROOT/cache"
PLAYLIST_DIR="$MUSIC_ROOT/playlists"
TXTS_DIR="$MUSIC_ROOT/txts"
DOWNLOADS_DIR="$MUSIC_ROOT/downloads"
DATA_DIR="$MUSIC_ROOT/data"
LOCK_DIR="$MUSIC_ROOT/locks"
LOCK_FILE="$LOCK_DIR/start.lock"
LOCK_FILE_D="$LOCK_FILE.d"
HISTORY_LOCK="$LOCK_DIR/history.lock"
LIKES_FILE="$DATA_DIR/likes"
HISTORY_FILE="$DATA_DIR/history"
TXT_STATE_FILE="$DATA_DIR/txt_state"
TXT_BG_GEN_FILE="$DATA_DIR/txt_bg_gen"
QUEUE_SNAPSHOT="$DATA_DIR/queue_snapshot.m3u"
MPV_LOG="$DATA_DIR/mpv.log"
LOCAL_INDEX="$DATA_DIR/local_index.tsv"
BOOKMARKS_FILE="$DATA_DIR/bookmarks"
AUTODJ_FILE="$DATA_DIR/autodj_enabled"
CONFIG_FILE="$MUSIC_ROOT/config"
PLUGINS_DIR="$MUSIC_ROOT/plugins"

# â”€â”€ defaults (overridable via config file) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CACHE_TTL=3600
HISTORY_MAX=500
DEFAULT_VOLUME=80
VOLUME_STEP=5
SEARCH_RESULTS=20
AUDIO_DEVICE_SPEAKERS=""
AUDIO_DEVICE_HEADPHONES=""
SCROBBLE_URL=""
YTDLP_MAX_AGE_DAYS=30
LASTFM_API_KEY=""
YOUTUBE_API_KEY=""         # v5-L: optional YouTube Data API v3 key for fast search
INVIDIOUS_HOST=""          # v5-L: optional Invidious instance e.g. "https://invidious.snopyta.org"
LOCAL_MUSIC_DIR="${HOME}/Music"
AUTODJ_ENABLED=0           # v5-R: auto-refill queue from Last.fm when empty
LYRICS_ENABLED=1           # v5-P: enable lrclib.net lyrics fetch

# â”€â”€ load user config â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# shellcheck disable=SC1090
[ -f "$CONFIG_FILE" ] && source "$CONFIG_FILE"

# v4-S â€” validate config (safe under set -u)
_validate_config() {
  local -a _cfg_checks
  _cfg_checks=(
    "CACHE_TTL:${CACHE_TTL}:1:86400"
    "HISTORY_MAX:${HISTORY_MAX}:10:100000"
    "DEFAULT_VOLUME:${DEFAULT_VOLUME}:0:150"
    "VOLUME_STEP:${VOLUME_STEP}:1:50"
    "SEARCH_RESULTS:${SEARCH_RESULTS}:1:50"
    "YTDLP_MAX_AGE_DAYS:${YTDLP_MAX_AGE_DAYS}:1:365"
  )
  local entry var val min max
  for entry in "${_cfg_checks[@]}"; do
    var="${entry%%:*}"; local _rest="${entry#*:}"
    val="${_rest%%:*}"; _rest="${_rest#*:}"
    min="${_rest%%:*}"; max="${_rest#*:}"
    if [[ ! "$val" =~ ^[0-9]+$ ]] || (( val < min || val > max )); then
      echo "${Y}âš  config: ${var}=${val} is invalid (expected integer ${min}â€“${max}), using default${X}" >&2
    fi
  done
  [[ "$CACHE_TTL"      =~ ^[0-9]+$ ]] || CACHE_TTL=3600
  [[ "$HISTORY_MAX"    =~ ^[0-9]+$ ]] || HISTORY_MAX=500
  [[ "$DEFAULT_VOLUME" =~ ^[0-9]+$ ]] || DEFAULT_VOLUME=80
  [[ "$VOLUME_STEP"    =~ ^[0-9]+$ ]] || VOLUME_STEP=5
  [[ "$SEARCH_RESULTS" =~ ^[0-9]+$ ]] || SEARCH_RESULTS=20
  (( DEFAULT_VOLUME > 150 )) && DEFAULT_VOLUME=150
  (( VOLUME_STEP > 50 ))    && VOLUME_STEP=5
}

# â”€â”€ colours â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
R=$'\e[0;31m'; G=$'\e[0;32m'; Y=$'\e[0;33m'
C=$'\e[0;36m'; W=$'\e[1;37m'; M=$'\e[0;35m'; X=$'\e[0m'
DIM=$'\e[2m'; BOLD=$'\e[1m'

# â”€â”€ OS detection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
_os() {
  case "$(uname -s)" in
    Darwin) echo "mac" ;;
    Linux)  echo "linux" ;;
    *)      echo "unknown" ;;
  esac
}
OS=$(_os)

# â”€â”€ cross-platform helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
_md5() {
  if [[ "$OS" == "mac" ]]; then md5
  else md5sum | cut -c1-32
  fi
}

_mtime() {
  local f="$1"
  if [[ "$OS" == "mac" ]]; then stat -f%m "$f" 2>/dev/null || echo 0
  else stat -c%Y "$f" 2>/dev/null || echo 0
  fi
}

_tac() {
  if command -v tac &>/dev/null; then tac "$@"
  else tail -r "$@"
  fi
}

# v5-J â€” _shuf1: reservoir sampling O(1) memory, unbiased
_shuf1() {
  local f="$1"
  [[ -s "$f" ]] || return 1
  awk 'BEGIN{srand()} {if(rand()<1/NR) r=$0} END{if(NR>0) print r}' "$f"
}

# â”€â”€ locking (v5-B: stale-steal no longer rmdir's unowned lock) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# _lock <lockfile_base> [timeout_seconds]
# Atomic sentinel: mkdir of <lockfile_base>.d
# Stale steal: only steals if the owning PID is dead AND we successfully
# mkdir AFTER removing the stale sentinel â€” never rmdir a live lock.
_lock() {
  local lf="$1" timeout="${2:-5}"
  local deadline=$(( $(date +%s) + timeout ))
  local steal_count=0 MAX_STEALS=3

  while true; do
    # Try atomic acquire
    if mkdir "${lf}.d" 2>/dev/null; then
      echo $$ > "$lf"
      return 0
    fi

    # Lock held â€” check if stale
    if [[ $(date +%s) -gt $deadline ]]; then
      if [[ $steal_count -lt $MAX_STEALS && -f "$lf" ]]; then
        local dead_pid; dead_pid=$(cat "$lf" 2>/dev/null)
        if [[ -n "$dead_pid" ]] && ! kill -0 "$dead_pid" 2>/dev/null; then
          # PID is dead. Remove PID file and sentinel, then retry mkdir.
          # v5-B: We remove sentinel only after verifying PID is dead,
          # and we immediately retry mkdir â€” we don't rmdir before owning.
          rm -f "$lf"
          rmdir "${lf}.d" 2>/dev/null
          steal_count=$(( steal_count + 1 ))
          deadline=$(( $(date +%s) + timeout ))
          continue  # immediately retry mkdir
        fi
      fi
      return 1  # live lock or max steals exceeded
    fi
    sleep 0.05
  done
}

_unlock() {
  local lf="$1"
  local stored_pid; stored_pid=$(cat "$lf" 2>/dev/null)
  if [[ "$stored_pid" == "$$" ]]; then
    rm -f "$lf"
    rmdir "${lf}.d" 2>/dev/null
  fi
}

# v5-W â€” graceful EXIT trap: always release locks on shell exit
trap '_unlock "$LOCK_FILE" 2>/dev/null; _unlock "$HISTORY_LOCK" 2>/dev/null' EXIT

# â”€â”€ binary resolution â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
_resolve_bin() {
  local name="$1"
  local found; found=$(command -v "$name" 2>/dev/null)
  [ -n "$found" ] && { echo "$found"; return 0; }
  for prefix in /opt/homebrew/bin /usr/local/bin /home/linuxbrew/.linuxbrew/bin; do
    [ -x "$prefix/$name" ] && { echo "$prefix/$name"; return 0; }
  done
  echo ""; return 1
}

YTDLP="${YTDLP:-$(_resolve_bin yt-dlp)}"
MPV="${MPV:-$(_resolve_bin mpv)}"
FZF="${FZF:-$(_resolve_bin fzf)}"
SOCAT="${SOCAT:-$(_resolve_bin socat)}"
JQ="${JQ:-$(_resolve_bin jq)}"
CURL="${CURL:-$(_resolve_bin curl)}"
CHAFA="${CHAFA:-$(_resolve_bin chafa)}"    # v5-O: optional, for album art
FFPROBE="${FFPROBE:-$(_resolve_bin ffprobe)}" # v5-X: optional, for local index

# â”€â”€ bootstrap dirs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
_bootstrap() {
  mkdir -p "$SOCKET_DIR" "$CACHE_DIR" "$PLAYLIST_DIR" \
           "$TXTS_DIR" "$DOWNLOADS_DIR" "$DATA_DIR" "$LOCK_DIR" "$PLUGINS_DIR"
  [[ ! -f "$LIKES_FILE" ]]   && touch "$LIKES_FILE"
  [[ ! -f "$HISTORY_FILE" ]] && touch "$HISTORY_FILE"
  [[ ! -f "$BOOKMARKS_FILE" ]] && touch "$BOOKMARKS_FILE"
  if [[ ! -f "$CONFIG_FILE" ]]; then
    cat > "$CONFIG_FILE" <<'EOF'
# m â€” user config  (uncomment + edit to override defaults)
# CACHE_TTL=3600
# HISTORY_MAX=500
# DEFAULT_VOLUME=80
# VOLUME_STEP=5
# SEARCH_RESULTS=20
# YTDLP_MAX_AGE_DAYS=30
# YTDLP=/usr/local/bin/yt-dlp
# MPV=/usr/local/bin/mpv
# AUDIO_DEVICE_SPEAKERS=coreaudio/BuiltInSpeakerDevice
# AUDIO_DEVICE_HEADPHONES=coreaudio/BuiltInHeadphoneOutputDevice
# SCROBBLE_URL=https://api.listenbrainz.org/1/submit-listens
# LASTFM_API_KEY=your_key_here      # enables real similar-track recommendations
# YOUTUBE_API_KEY=your_key_here     # v5: enables fast YouTube Data API search (ms vs s)
# INVIDIOUS_HOST=https://invidious.snopyta.org  # v5: privacy-friendly search alternative
# LOCAL_MUSIC_DIR=$HOME/Music       # v5: local library root for m index
# AUTODJ_ENABLED=0                  # v5: 1 = auto-refill queue from Last.fm when empty
# LYRICS_ENABLED=1                  # v5: 0 = disable real-time lyrics
EOF
  fi
}
_bootstrap

# â”€â”€ logging helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
_die()  { echo "${R}âœ– $*${X}" >&2; exit 1; }
_err()  { echo "${R}âœ– $*${X}" >&2; return 1; }
_ok()   { echo "${G}âœ” $*${X}"; }
_info() { echo "${C}â†’ $*${X}"; }
_warn() { echo "${Y}âš  $*${X}"; }

# â”€â”€ dependency check â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
_check_deps() {
  local missing=0
  for bin in "$YTDLP" "$MPV" "$FZF" "$SOCAT" "$JQ"; do
    if [[ -z "$bin" || ! -x "$bin" ]]; then
      _warn "missing binary: ${bin:-<unresolved>}"
      missing=1
    fi
  done
  if [[ $missing -eq 1 ]]; then
    _die "install missing deps:\n  macOS: brew install yt-dlp mpv fzf socat jq\n  Linux: sudo apt install mpv socat jq fzf && pip install yt-dlp"
  fi
  # Optional deps: just warn, don't die
  [[ -z "$CURL" || ! -x "$CURL" ]] && _warn "curl not found â€” API search, lyrics, scrobble disabled"
  [[ -z "$CHAFA" || ! -x "$CHAFA" ]] && true  # silent, chafa is optional
}
_check_deps
_validate_config

# â”€â”€ yt-dlp freshness check â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
_check_ytdlp_age() {
  local ver_file="$CACHE_DIR/.ytdlp_version_check"
  local age; age=$(_cache_age "$ver_file" 2>/dev/null || echo 99999)
  (( age < 86400 )) && return
  touch "$ver_file"
  local ver_str; ver_str=$("$YTDLP" --version 2>/dev/null | head -1)
  local ver_date; ver_date=$(echo "$ver_str" | grep -oE '^[0-9]{4}\.[0-9]{2}\.[0-9]{2}')
  [[ -z "$ver_date" ]] && return
  local ver_epoch
  if [[ "$OS" == "mac" ]]; then
    ver_epoch=$(date -j -f "%Y.%m.%d" "$ver_date" "+%s" 2>/dev/null || echo 0)
  else
    ver_epoch=$(date -d "${ver_date//./-}" "+%s" 2>/dev/null || echo 0)
  fi
  local now; now=$(date +%s)
  local days_old=$(( (now - ver_epoch) / 86400 ))
  if (( days_old > YTDLP_MAX_AGE_DAYS )); then
    _warn "yt-dlp is ${days_old} days old (${ver_str}) â€” run: m update"
  fi
}

# â”€â”€ audio device detection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
_detect_audio_devices() {
  [[ "$OS" != "mac" ]] && return
  [[ -z "$AUDIO_DEVICE_SPEAKERS"   ]] && AUDIO_DEVICE_SPEAKERS="coreaudio/BuiltInSpeakerDevice"
  [[ -z "$AUDIO_DEVICE_HEADPHONES" ]] && AUDIO_DEVICE_HEADPHONES="coreaudio/BuiltInHeadphoneOutputDevice"
}
_detect_audio_devices

# â”€â”€ daemon management â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
_start() {
  [ -S "$SOCKET" ] && return 0
  if ! _lock "$LOCK_FILE" 5; then
    _info "waiting for daemon to start..."
    for i in $(seq 1 30); do
      sleep 0.3
      [ -S "$SOCKET" ] && return 0
    done
    _die "daemon failed to start (lock timeout)"
  fi
  if [ -S "$SOCKET" ]; then
    _unlock "$LOCK_FILE"; return 0
  fi
  _info "starting daemon..."
  local device_flag=""
  [[ -n "$AUDIO_DEVICE_SPEAKERS" ]] && device_flag="--audio-device=$AUDIO_DEVICE_SPEAKERS"
  "$MPV" --no-video --idle=yes \
    --input-ipc-server="$SOCKET" \
    --script-opts=ytdl_hook-ytdl_path="$YTDLP" \
    ${device_flag:+"$device_flag"} \
    --volume="$DEFAULT_VOLUME" \
    --quiet --really-quiet \
    --ytdl-format="bestaudio/best" \
    --cache=yes --cache-secs=60 \
    --demuxer-max-bytes=50MiB \
    --prefetch-playlist=yes \
    --save-position-on-quit=no \
    2>>"$MPV_LOG" &
  local mpv_pid=$!
  disown $mpv_pid
  echo $mpv_pid > "$MPV_PID_FILE"
  for i in $(seq 1 30); do
    sleep 0.3
    if [ -S "$SOCKET" ]; then
      _unlock "$LOCK_FILE"; return 0
    fi
  done
  _unlock "$LOCK_FILE"
  rm -f "$MPV_PID_FILE"
  _die "mpv daemon failed to start â€” check: $MPV_LOG"
}

_need() {
  if [ ! -S "$SOCKET" ]; then
    _die "daemon not running â€” run: m start"
  fi
  if ! echo '{"command":["get_version"]}' \
        | "$SOCAT" -t 2 - "$SOCKET" >/dev/null 2>&1; then
    _die "daemon socket exists but mpv is unresponsive â€” run: m stop && m start"
  fi
}

# â”€â”€ IPC helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
_cmd() {
  echo "$1" | "$SOCAT" - "$SOCKET" 2>/dev/null
}

_silent() {
  echo "$1" | "$SOCAT" - "$SOCKET" >/dev/null 2>&1
}

_silent_retry() {
  local json="$1" attempts="${2:-3}" i
  for i in $(seq 1 $attempts); do
    if echo "$json" | "$SOCAT" - "$SOCKET" >/dev/null 2>&1; then return 0; fi
    sleep 0.1
  done
  return 1
}

_get() {
  local raw
  raw=$(_cmd "{\"command\":[\"get_property\",\"$1\"]}")
  echo "$raw" | "$JQ" -r '.data // empty' 2>/dev/null
}

# v5-D â€” _get_checked: distinguishes "unavailable" from "still loading"
# Returns the value, or empty string. Sets _GET_ERROR to "unavailable" if
# mpv explicitly says property is unavailable (vs just not ready yet).
_GET_ERROR=""
_get_checked() {
  _GET_ERROR=""
  local raw; raw=$(_cmd "{\"command\":[\"get_property\",\"$1\"]}")
  local err; err=$(echo "$raw" | "$JQ" -r '.error // empty' 2>/dev/null)
  if [[ "$err" == "property unavailable" || "$err" == "invalid parameter" ]]; then
    _GET_ERROR="unavailable"
    echo ""
    return 1
  fi
  echo "$raw" | "$JQ" -r '.data // empty' 2>/dev/null
}

_get_multi() {
  local props_json
  props_json=$(printf '"%s",' "$@" | sed 's/,$//')
  local raw
  raw=$(_cmd "{\"command\":[\"get_property_list\",[${props_json}]]}" 2>/dev/null)
  if ! echo "$raw" | "$JQ" -e '.data | type == "object"' >/dev/null 2>&1; then
    local result="{" first=1
    for prop in "$@"; do
      local val; val=$(_get "$prop")
      [[ $first -eq 0 ]] && result="${result},"
      result="${result}\"${prop}\":$(echo "$val" | "$JQ" -Rn 'input' 2>/dev/null || echo "null")"
      first=0
    done
    result="${result}}"
    echo "$result"
  else
    echo "$raw" | "$JQ" '.data // {}' 2>/dev/null
  fi
}

# v5-A â€” _wait_prop: yields 0.3s before first poll, checks for hard errors,
# retries if title looks like a URL (mpv not yet resolved metadata)
_wait_prop() {
  local prop="$1" max="${2:-60}" val
  local -a spinner
  spinner=('â ‹' 'â ™' 'â ¹' 'â ¸' 'â ¼' 'â ´' 'â ¦' 'â §' 'â ‡' 'â ')
  local si=0 sleep_ms=100

  # v5-A: brief initial yield so mpv can start the load before we poll
  sleep 0.3

  for i in $(seq 1 "$max"); do
    val=$(_get_checked "$prop")

    # v5-D: hard error â†’ stop spinning immediately
    if [[ "$_GET_ERROR" == "unavailable" ]]; then
      printf '\r\e[2K' >&2
      echo ""
      return 1
    fi

    # v5-A: reject if value looks like a raw URL (title not resolved yet)
    if [[ -n "$val" && "$val" != http* && "$val" != "null" ]]; then
      printf '\r\e[2K' >&2
      echo "$val"
      return 0
    fi

    printf '\r\e[2K  %s buffering...' "${spinner[$(( (si % ${#spinner[@]}) + 1 ))]}" >&2
    si=$(( si + 1 ))
    (( i % 10 == 0 && sleep_ms < 800 )) && sleep_ms=$(( sleep_ms * 2 ))
    sleep $(awk "BEGIN{printf \"%.3f\", $sleep_ms/1000}")
  done

  printf '\r\e[2K' >&2

  # v5-A: one final retry with a longer wait if we timed out
  sleep 1
  val=$(_get media-title)
  if [[ -n "$val" && "$val" != http* ]]; then
    echo "$val"; return 0
  fi

  echo ""
}

_ipc_cmd() {
  local cmd_json
  cmd_json=$("$JQ" -cn --args '{"command":$ARGS.positional}' -- "$@")
  _silent_retry "$cmd_json"
}

_ipc_loadfile() {
  local url="$1" mode="${2:-append-play}"
  local json
  json=$("$JQ" -cn --arg url "$url" --arg mode "$mode" \
    '{"command":["loadfile",$url,$mode]}')
  _silent_retry "$json"
}

# â”€â”€ cache helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# v4-T: include $USER in cache key
_cache_key() {
  printf '%s\0%s' "${USER:-$(id -un)}" "$1" | _md5 | tr -d ' \n'
}

_cache_age() {
  local f="$1"
  [ -f "$f" ] || { echo 9999; return; }
  echo $(( $(date +%s) - $(_mtime "$f") ))
}

# â”€â”€ v5-L â€” Fast search: YouTube Data API v3 / Invidious / yt-dlp fallback â”€â”€â”€â”€â”€
#
# Priority: YouTube Data API v3 (if YOUTUBE_API_KEY set)
#         â†’ Invidious API (if INVIDIOUS_HOST set)
#         â†’ yt-dlp scrape (always available, slowest)
#
# Returns lines of format: "Title | Duration | URL"

_search_youtube_api() {
  local query="$1" n="${2:-$SEARCH_RESULTS}"
  [[ -z "$YOUTUBE_API_KEY" || -z "$CURL" || ! -x "$CURL" ]] && return 1

  local encoded_q; encoded_q=$(printf '%s' "$query" | "$JQ" -Rr '@uri' 2>/dev/null)
  [[ -z "$encoded_q" ]] && return 1

  local resp
  resp=$("$CURL" -sf --max-time 8 \
    "https://www.googleapis.com/youtube/v3/search?part=snippet&type=video&videoCategoryId=10&maxResults=${n}&q=${encoded_q}&key=${YOUTUBE_API_KEY}" \
    2>/dev/null) || return 1

  # Extract video IDs, then fetch durations in one batch call
  local ids; ids=$(echo "$resp" | "$JQ" -r '.items[].id.videoId' 2>/dev/null | tr '\n' ',' | sed 's/,$//')
  [[ -z "$ids" ]] && return 1

  local details
  details=$("$CURL" -sf --max-time 8 \
    "https://www.googleapis.com/youtube/v3/videos?part=contentDetails,snippet&id=${ids}&key=${YOUTUBE_API_KEY}" \
    2>/dev/null) || return 1

  # Format output: "Title | Duration | URL"
  echo "$details" | "$JQ" -r '
    .items[] |
    .id as $id |
    .snippet.title as $title |
    (.contentDetails.duration |
      ltrimstr("PT") |
      # parse ISO 8601 duration PT#H#M#S
      (capture("(?:(?<h>[0-9]+)H)?(?:(?<m>[0-9]+)M)?(?:(?<s>[0-9]+)S)?") |
       ((if .h then (.h|tonumber)*3600 else 0 end) +
        (if .m then (.m|tonumber)*60  else 0 end) +
        (if .s then (.s|tonumber)     else 0 end))) |
      . as $total |
      "\(if $total >= 3600 then "\($total/3600|floor):" else "" end)\(($total%3600)/60|floor|tostring|if length<2 then "0"+. else . end):\($total%60|floor|tostring|if length<2 then "0"+. else . end)"
    ) as $dur |
    "\($title) | \($dur) | https://www.youtube.com/watch?v=\($id)"
  ' 2>/dev/null
}

_search_invidious() {
  local query="$1" n="${2:-$SEARCH_RESULTS}"
  [[ -z "$INVIDIOUS_HOST" || -z "$CURL" || ! -x "$CURL" ]] && return 1

  local encoded_q; encoded_q=$(printf '%s' "$query" | "$JQ" -Rr '@uri' 2>/dev/null)
  [[ -z "$encoded_q" ]] && return 1

  local resp
  resp=$("$CURL" -sf --max-time 8 \
    "${INVIDIOUS_HOST}/api/v1/search?q=${encoded_q}&type=video&fields=title,videoId,lengthSeconds&page=1" \
    2>/dev/null) || return 1

  echo "$resp" | "$JQ" -r --argjson n "$n" '
    .[:$n][] |
    .title as $t |
    .videoId as $id |
    (.lengthSeconds |
      . as $total |
      "\(if $total >= 3600 then "\($total/3600|floor):" else "" end)\(($total%3600)/60|floor|tostring|if length<2 then "0"+. else . end):\($total%60|floor|tostring|if length<2 then "0"+. else . end)"
    ) as $dur |
    "\($t) | \($dur) | https://www.youtube.com/watch?v=\($id)"
  ' 2>/dev/null
}

_search_ytdlp() {
  local query="$1" n="${2:-$SEARCH_RESULTS}"
  local results
  results=$("$YTDLP" "ytsearch${n}:${query}" \
    --print "%(title)s | %(duration_string)s | %(webpage_url)s" \
    --no-download --no-warnings 2>/dev/null)

  # v5-Z: PIPESTATUS check â€” ytdlp exit code captured before pipe
  local ytdlp_rc=$?
  [[ $ytdlp_rc -ne 0 ]] && return 1

  echo "$results"
}

# _do_search: tries API â†’ Invidious â†’ yt-dlp, caches result
_do_search() {
  local query="$1" n="${2:-$SEARCH_RESULTS}"
  local key="$CACHE_DIR/$(_cache_key "$query").cache"

  if [ -f "$key" ] && [ "$(_cache_age "$key")" -lt "$CACHE_TTL" ]; then
    cat "$key"; return 0
  fi

  local results=""
  if [[ -n "$YOUTUBE_API_KEY" ]]; then
    results=$(_search_youtube_api "$query" "$n")
  fi
  if [[ -z "$results" && -n "$INVIDIOUS_HOST" ]]; then
    results=$(_search_invidious "$query" "$n")
  fi
  if [[ -z "$results" ]]; then
    _info "searching (yt-dlp)..." >&2
    results=$(_search_ytdlp "$query" "$n")
  fi

  local valid_count; valid_count=$(echo "$results" | grep -cE 'https?://' 2>/dev/null || echo 0)
  if [[ -n "$results" ]] && (( valid_count >= 1 )); then
    echo "$results" > "$key"
    echo "$results"
    return 0
  fi

  rm -f "$key"
  return 1
}

# â”€â”€ v5-M â€” Live async fzf search: opens instantly, results load as you type â”€â”€
# Uses fzf --bind change:reload so the UI is immediate with no initial wait.
# If YOUTUBE_API_KEY or INVIDIOUS_HOST is set, this is near-instant.
# Falls back to yt-dlp otherwise (slower but still async).

_pick_async() {
  # Build the reload command â€” uses the same search priority
  local search_cmd
  if [[ -n "$YOUTUBE_API_KEY" ]]; then
    # Fast path: API search inline (no yt-dlp spawn)
    search_cmd="$0 _internal_search_api {q}"
  else
    # Slower but works without API key
    search_cmd="\"$YTDLP\" \"ytsearch${SEARCH_RESULTS}:{q}\" --print '%(title)s | %(duration_string)s | %(webpage_url)s' --no-download --no-warnings 2>/dev/null || echo 'no results'"
  fi

  local result
  result=$(FZF_DEFAULT_COMMAND="" "$FZF" \
    --height 60% --reverse \
    --prompt "ðŸŽµ " \
    --header "Type to search YouTube Â· ENTER select Â· ESC cancel" \
    --preview 'echo {} | sed "s/ | /\n/g"' \
    --preview-window=down:3:wrap \
    --ansi \
    --disabled \
    --query "" \
    --bind "change:reload:$search_cmd 2>/dev/null || echo ''" \
    --bind "start:reload:echo ''" \
    2>/dev/null) || return 1

  echo "$result" | awk -F ' \| ' '{print $NF}'
}

# _pick: standard search with cache, then fzf picker
# Uses async UI if available, cached results otherwise
_pick() {
  local query="$1"
  local key="$CACHE_DIR/$(_cache_key "$query").cache"
  local results

  if [ -f "$key" ] && [ "$(_cache_age "$key")" -lt "$CACHE_TTL" ]; then
    results=$(cat "$key")
    _info "instant results (cached)" >&2
  else
    [[ -n "$YOUTUBE_API_KEY" || -n "$INVIDIOUS_HOST" ]] && _info "searching (API)..." >&2 || _info "searching (yt-dlp â€” add YOUTUBE_API_KEY to config for instant search)..." >&2
    results=$(_do_search "$query")
  fi

  [[ -z "$results" ]] && { _warn "no results for: $query"; return 1; }

  echo "$results" | "$FZF" \
    --height 55% --reverse \
    --prompt "ðŸŽµ " \
    --header "ENTER select Â· ESC cancel Â· cached=instant | ${#results}" \
    --preview 'echo {} | sed "s/ | /\n/g"' \
    --preview-window=down:3:wrap \
    --ansi \
  | awk -F ' \| ' '{print $NF}'
}

# â”€â”€ history helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# v5-I â€” _log_history: rolling dedup â€” won't log same URL within last 50 entries
_log_history() {
  local title="$1" url="$2"
  [ -z "$url" ] && return

  if _lock "$HISTORY_LOCK" 3; then
    # Dedup: check last 50 entries for this URL
    local recent_count
    recent_count=$(tail -50 "$HISTORY_FILE" 2>/dev/null | grep -cF "$url" || echo 0)
    if (( recent_count == 0 )); then
      printf '%s\t%s\t%s\n' "$(date '+%Y-%m-%d %H:%M')" "$title" "$url" >> "$HISTORY_FILE"
      local lines; lines=$(wc -l < "$HISTORY_FILE" | tr -d ' ')
      if [ "$lines" -gt "$HISTORY_MAX" ]; then
        local tmpf; tmpf=$(mktemp "$HISTORY_FILE.XXXXXX")
        tail -n "$HISTORY_MAX" "$HISTORY_FILE" > "$tmpf" \
          && mv "$tmpf" "$HISTORY_FILE" \
          || rm -f "$tmpf"
      fi
    fi
    _unlock "$HISTORY_LOCK"
  else
    # Lock timeout â€” append without dedup/trim
    printf '%s\t%s\t%s\n' "$(date '+%Y-%m-%d %H:%M')" "$title" "$url" >> "$HISTORY_FILE"
  fi

  _scrobble "$title" "$url" &
  disown $! 2>/dev/null
}

_scrobble() {
  [[ -z "${SCROBBLE_URL:-}" ]] && return 0
  local title="$1" url="$2"
  command -v curl >/dev/null 2>&1 || return 0
  local payload
  payload=$("$JQ" -cn \
    --arg title "$title" --arg url "$url" --arg ts "$(date +%s)" \
    '{listen_type:"single",payload:[{listened_at:($ts|tonumber),track_metadata:{track_name:$title,additional_info:{media_player:"m-cli",origin_url:$url}}}]}')
  curl -s -X POST "$SCROBBLE_URL" \
    -H "Content-Type: application/json" \
    -d "$payload" >/dev/null 2>&1 || true
}

# â”€â”€ v5-E â€” _clean_url: handles Shorts, SoundCloud, Bandcamp, local files â”€â”€â”€â”€â”€
_clean_url() {
  local url="$1"

  # Don't mangle local file paths
  [[ "$url" == /* || "$url" == ./* || "$url" == ../* ]] && { echo "$url"; return; }
  [[ -f "$url" ]] && { echo "$url"; return; }

  local vid=""

  # Standard YouTube watch URL: ?v= or &v=
  vid=$(printf '%s' "$url" | grep -oE '[?&]v=([A-Za-z0-9_-]{11})' | head -1 | cut -d= -f2)

  # YouTube Shorts: /shorts/ID (v5-E)
  if [ -z "$vid" ]; then
    vid=$(printf '%s' "$url" | grep -oE '/shorts/([A-Za-z0-9_-]{11})' | head -1 | grep -oE '[A-Za-z0-9_-]{11}$')
  fi

  # youtu.be short links
  if [ -z "$vid" ]; then
    vid=$(printf '%s' "$url" | grep -oE 'youtu\.be/([A-Za-z0-9_-]{11})' | head -1 \
          | grep -oE '[A-Za-z0-9_-]{11}$')
  fi

  # YouTube live streams: /live/ID
  if [ -z "$vid" ]; then
    vid=$(printf '%s' "$url" | grep -oE '/live/([A-Za-z0-9_-]{11})' | head -1 | grep -oE '[A-Za-z0-9_-]{11}$')
  fi

  # If we got a YouTube video ID, normalise to canonical URL
  [ -n "$vid" ] && { echo "https://www.youtube.com/watch?v=$vid"; return; }

  # Non-YouTube (SoundCloud, Bandcamp, etc.) â€” return as-is (v5-E)
  echo "$url"
}

# â”€â”€ local file detection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
_is_local_file() {
  local arg="$1"
  [[ -f "$arg" || "$arg" == /* || "$arg" == ./* || "$arg" == ../* ]] && return 0
  return 1
}

# â”€â”€ queue snapshot â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
_queue_snapshot() {
  [ ! -S "$SOCKET" ] && return
  local raw; raw=$(_cmd '{"command":["get_property","playlist"]}' 2>/dev/null)
  [ -z "$raw" ] && return
  local urls; urls=$(echo "$raw" | "$JQ" -r '.data[].filename // empty' 2>/dev/null)
  [ -z "$urls" ] && return
  local tmpf; tmpf=$(mktemp "$DATA_DIR/snap.XXXXXX")
  echo "$urls" > "$tmpf" && mv "$tmpf" "$QUEUE_SNAPSHOT" || rm -f "$tmpf"
}

# â”€â”€ Auto-DJ: refill queue from Last.fm when empty (v5-R) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
_autodj_check() {
  [[ "$AUTODJ_ENABLED" != "1" ]] && return
  [[ ! -f "$AUTODJ_FILE" ]] && return
  [ ! -S "$SOCKET" ] && return

  local pl_count
  pl_count=$(_cmd '{"command":["get_property","playlist"]}' | "$JQ" '.data|length' 2>/dev/null || echo 0)
  (( pl_count > 2 )) && return  # queue still has tracks, don't refill

  [ -s "$HISTORY_FILE" ] || return
  local seed_title; seed_title=$(_tac "$HISTORY_FILE" | awk -F'\t' '!seen[$2]++ {print $2; exit}')
  [ -z "$seed_title" ] && return

  _info "Auto-DJ: refilling queue based on: $seed_title" >&2

  local similar_title=""
  if [[ -n "${LASTFM_API_KEY:-}" ]] && command -v curl >/dev/null 2>&1; then
    local artist track
    if echo "$seed_title" | grep -q ' - '; then
      artist=$(echo "$seed_title" | cut -d'-' -f1 | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
      track=$(echo "$seed_title"  | cut -d'-' -f2- | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
    else
      artist=""; track="$seed_title"
    fi
    local enc_artist enc_track
    enc_artist=$(printf '%s' "$artist" | "$JQ" -Rr '@uri' 2>/dev/null)
    enc_track=$(printf '%s' "$track" | "$JQ" -Rr '@uri' 2>/dev/null)
    local lastfm_resp
    lastfm_resp=$(curl -s --max-time 8 \
      "https://ws.audioscrobbler.com/2.0/?method=track.getsimilar&artist=${enc_artist}&track=${enc_track}&api_key=${LASTFM_API_KEY}&format=json&limit=10" \
      2>/dev/null)
    similar_title=$(echo "$lastfm_resp" | "$JQ" -r \
      '.similartracks.track[] | "\(.artist.name) - \(.name)"' 2>/dev/null \
      | grep -v "^null" | head -5 \
      | awk 'BEGIN{srand()} {a[NR]=$0} END{if(NR>0) print a[int(rand()*NR)+1]}')
  fi

  local query="${similar_title:-$seed_title}"
  local results; results=$(_do_search "$query" 3) || return
  local url; url=$(echo "$results" | head -1 | awk -F ' \| ' '{print $NF}')
  [ -z "$url" ] && return
  _ipc_loadfile "$url" "append-play"
  _info "Auto-DJ: added $(echo "$results" | head -1 | awk -F ' \| ' '{print $1}')" >&2
}

# â”€â”€ subcommands â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

do_queue_restore() {
  [ -f "$QUEUE_SNAPSHOT" ] || { _warn "no queue snapshot found â€” nothing to restore"; return; }
  local count; count=$(grep -c . "$QUEUE_SNAPSHOT" 2>/dev/null || echo 0)
  [ "$count" -eq 0 ] && { _warn "queue snapshot is empty"; return; }
  _start
  _silent '{"command":["playlist-clear"]}'
  local loaded=0
  while IFS= read -r line; do
    [ -z "$line" ] && continue
    _ipc_loadfile "$line" "append-play"
    loaded=$(( loaded + 1 ))
  done < "$QUEUE_SNAPSHOT"
  _ok "restored queue: ${loaded} tracks  (use: m now)"
}

do_play() {
  _start
  local url

  if _is_local_file "${1:-}"; then
    url="$1"
    [[ -f "$url" ]] || { _err "file not found: $url"; return 1; }
    _info "loading local file..."
  else
    url=$(_pick "${1:-}") || return 1
  fi

  [ -z "$url" ] && { _warn "cancelled"; return; }

  _silent '{"command":["playlist-clear"]}'
  _info "buffering..."
  _ipc_loadfile "$url" "replace"

  # v5-A: _wait_prop now yields 0.3s and retries on URL-like titles
  local title; title=$(_wait_prop media-title 60)
  _ok "â–¶  ${title:-unknown}"
  _log_history "${title:-unknown}" "$(_clean_url "$url")"
  _queue_snapshot
  # v5-R: auto-DJ check after play (background, non-blocking)
  (_autodj_check) &
  disown $! 2>/dev/null
}

# v5-S â€” do_add_next: insert track immediately after current position
do_add_next() {
  _start
  local url

  if _is_local_file "${1:-}"; then
    url="$1"
    [[ -f "$url" ]] || { _err "file not found: $url"; return 1; }
  else
    url=$(_pick "${1:-}") || return 1
  fi

  [ -z "$url" ] && { _warn "cancelled"; return; }

  # Get current playing index (0-based), insert at current+1
  local cur_idx; cur_idx=$(_get playlist-playing-pos)
  cur_idx="${cur_idx:-0}"
  local insert_pos=$(( cur_idx + 1 ))

  _ipc_loadfile "$url" "append"
  # Move newly appended track to insert_pos
  local pl_count
  pl_count=$(_cmd '{"command":["get_property","playlist"]}' | "$JQ" '.data|length' 2>/dev/null || echo 0)
  local last_idx=$(( pl_count - 1 ))
  if (( last_idx > insert_pos )); then
    _silent "{\"command\":[\"playlist-move\",${last_idx},${insert_pos}]}"
  fi
  _ok "âž• added to play next (position $((insert_pos + 1)))"
  _queue_snapshot
}

do_add() {
  _start
  local url

  if _is_local_file "${1:-}"; then
    url="$1"
    [[ -f "$url" ]] || { _err "file not found: $url"; return 1; }
  else
    url=$(_pick "${1:-}") || return 1
  fi

  [ -z "$url" ] && { _warn "cancelled"; return; }

  local existing
  existing=$(_cmd '{"command":["get_property","playlist"]}' \
    | "$JQ" -r '.data[].filename' 2>/dev/null | grep -cF "$url" 2>/dev/null || echo 0)
  if (( existing > 0 )); then
    _warn "already in queue â€” use -f to force add"
    return
  fi

  _ipc_loadfile "$url" "append-play"
  _ok "âž• added to queue"
  _queue_snapshot
}

do_add_force() {
  _start
  local url

  if _is_local_file "${1:-}"; then
    url="$1"
    [[ -f "$url" ]] || { _err "file not found: $url"; return 1; }
  else
    url=$(_pick "${1:-}") || return 1
  fi

  [ -z "$url" ] && { _warn "cancelled"; return; }
  _ipc_loadfile "$url" "append-play"
  _ok "âž• force-added to queue"
  _queue_snapshot
}

do_pause() {
  _need
  _silent '{"command":["cycle","pause"]}'
  local p; p=$(_get pause)
  [ "$p" = "true" ] && _info "â¸  paused" || _info "â–¶  resumed"
}

do_next() {
  _need
  _silent '{"command":["playlist-next"]}'
  local title; title=$(_wait_prop media-title 20)
  _ok "â­  ${title:-end of queue}"
  (_autodj_check) &
  disown $! 2>/dev/null
}

do_prev() {
  _need
  _silent '{"command":["playlist-prev"]}'
  local title; title=$(_wait_prop media-title 20)
  _ok "â®  ${title:-beginning of queue}"
}

do_stop() {
  _txt_kill_bg_job
  _sleep_timer_cancel

  if [[ -f "$MPV_PID_FILE" ]]; then
    local pid; pid=$(cat "$MPV_PID_FILE" 2>/dev/null)
    if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
      kill "$pid" 2>/dev/null
      for i in $(seq 1 20); do
        sleep 0.1
        kill -0 "$pid" 2>/dev/null || break
      done
      kill -9 "$pid" 2>/dev/null
    fi
    rm -f "$MPV_PID_FILE"
  else
    pkill -f "input-ipc-server=${SOCKET}" 2>/dev/null
  fi
  rm -f "$SOCKET" "$LOCK_FILE"
  rmdir "$LOCK_FILE_D" 2>/dev/null
  _ok "stopped"
}

do_start() {
  _start && _ok "daemon ready"
}

do_vol() {
  _need
  case "${1:-}" in
    +)
      _silent "{\"command\":[\"add\",\"volume\",${VOLUME_STEP}]}"
      local v; v=$(_get volume | awk '{printf "%.0f",$1}')
      (( v > 150 )) && _silent '{"command":["set_property","volume",150]}'
      ;;
    -)
      _silent "{\"command\":[\"add\",\"volume\",-${VOLUME_STEP}]}"
      local v; v=$(_get volume | awk '{printf "%.0f",$1}')
      (( v < 0 )) && _silent '{"command":["set_property","volume",0]}'
      ;;
    '')
      local v; v=$(_get volume)
      _info "volume: $(echo "$v" | awk '{printf "%.0f%%",$1}')"
      return
      ;;
    *)
      [[ "${1:-}" =~ ^[0-9]+$ ]] || { _err "usage: m vol [0-150 | + | -]"; return 1; }
      (( $1 > 150 )) && { _err "max volume is 150"; return 1; }
      _silent "{\"command\":[\"set_property\",\"volume\",$1]}"
      ;;
  esac
  local v; v=$(_get volume)
  _info "volume: $(echo "$v" | awk '{printf "%.0f%%",$1}')"
}

do_seek() {
  _need
  [ -z "${1:-}" ] && { _err "usage: m seek [+N | -N | N | MM:SS]"; return 1; }
  local input="$1"
  local secs="$input"

  if echo "$input" | grep -qE '^[+-]?[0-9]+:[0-9]{2}$'; then
    local sign="" ts="$input"
    [[ "$input" == +* ]] && { sign="+"; ts="${input#+}"; }
    [[ "$input" == -* ]] && { sign="-"; ts="${input#-}"; }
    local m s
    m=$(echo "$ts" | cut -d: -f1 | sed 's/^0*//'); m=${m:-0}
    s=$(echo "$ts" | cut -d: -f2 | sed 's/^0*//'); s=${s:-0}
    secs="${sign}$(( m * 60 + s ))"
  fi

  case "$secs" in
    +*)
      local n="${secs#+}"
      [[ "$n" =~ ^[0-9]+$ ]] || { _err "invalid seek value: $input"; return 1; }
      _silent "{\"command\":[\"seek\",\"${n}\",\"relative\"]}"
      ;;
    -*)
      local n="${secs#-}"
      [[ "$n" =~ ^[0-9]+$ ]] || { _err "invalid seek value: $input"; return 1; }
      _silent "{\"command\":[\"seek\",\"-${n}\",\"relative\"]}"
      ;;
    *)
      [[ "$secs" =~ ^[0-9]+$ ]] || { _err "invalid seek value: $input"; return 1; }
      _silent "{\"command\":[\"seek\",\"$secs\",\"absolute\"]}"
      ;;
  esac

  sleep 0.1
  local pos; pos=$(_get time-pos)
  local dur; dur=$(_get duration)
  pos=$(echo "$pos" | awk '{printf "%d:%02d",$1/60,$1%60}' 2>/dev/null)
  dur=$(echo "$dur" | awk '{printf "%d:%02d",$1/60,$1%60}' 2>/dev/null)

  # v5: mini progress bar after seek
  local pos_i dur_i pct bar_fill bar_empty
  pos_i=$(echo "$pos" | awk -F: '{print $1*60+$2}' 2>/dev/null || echo 0)
  dur_i=$(echo "$dur" | awk -F: '{print $1*60+$2}' 2>/dev/null || echo 1)
  (( dur_i < 1 )) && dur_i=1
  pct=$(( pos_i * 100 / dur_i ))
  bar_fill=$(printf '%*s' "$(( pct * 20 / 100 ))" '' | tr ' ' 'â”')
  bar_empty=$(printf '%*s' "$(( 20 - pct * 20 / 100 ))" '' | tr ' ' 'â”€')
  _info "â© ${pos} / ${dur}  [${bar_fill}${bar_empty}] ${pct}%"
}

do_speed() {
  _need
  case "${1:-}" in
    +)  _silent '{"command":["multiply","speed",1.1]}' ;;
    -)  _silent '{"command":["multiply","speed",0.909090909]}' ;;
    r)  _silent '{"command":["set_property","speed",1.0]}'; _info "speed: 1.0x"; return ;;
    '')  { _err "usage: m speed [0.25-4.0 | + | - | r]"; return 1; } ;;
    *)
      [[ "${1:-}" =~ ^[0-9]+(\.[0-9]+)?$ ]] || { _err "usage: m speed [0.25-4.0 | + | - | r]"; return 1; }
      (( $(echo "$1 < 0.25" | awk '{print ($1<0.25)?1:0}') )) && { _err "min speed is 0.25"; return 1; }
      (( $(echo "$1 > 4.0"  | awk '{print ($1>4.0)?1:0}') )) && { _err "max speed is 4.0"; return 1; }
      _silent "{\"command\":[\"set_property\",\"speed\",$1]}"
      ;;
  esac
  local sp; sp=$(_get speed)
  _info "speed: $(echo "$sp" | awk '{printf "%.3fx",$1}')"
}

do_hp() {
  _need
  [[ -z "${AUDIO_DEVICE_HEADPHONES:-}" ]] && { _err "headphone device not configured â€” set AUDIO_DEVICE_HEADPHONES in $CONFIG_FILE"; return 1; }
  _silent "{\"command\":[\"set_property\",\"audio-device\",\"$AUDIO_DEVICE_HEADPHONES\"]}"
  _ok "ðŸŽ§ headphones"
}

do_sp() {
  _need
  [[ -z "${AUDIO_DEVICE_SPEAKERS:-}" ]] && { _err "speaker device not configured â€” set AUDIO_DEVICE_SPEAKERS in $CONFIG_FILE"; return 1; }
  _silent "{\"command\":[\"set_property\",\"audio-device\",\"$AUDIO_DEVICE_SPEAKERS\"]}"
  _ok "ðŸ”Š speakers"
}

do_shuffle() { _need; _silent '{"command":["playlist-shuffle"]}'; _ok "ðŸ”€ shuffled"; }

do_repeat() {
  _need
  _silent '{"command":["cycle","loop-playlist"]}'
  local state; state=$(_get loop-playlist)
  _info "ðŸ” repeat: ${state}"
}

do_repeat_one() {
  _need
  _silent '{"command":["cycle","loop-file"]}'
  local state; state=$(_get loop-file)
  _info "ðŸ”‚ repeat-one: ${state}"
}

do_clear() { _need; _silent '{"command":["playlist-clear"]}'; _ok "ðŸ—‘  queue cleared"; }

do_now() {
  _need
  local title pos dur paused speed
  title=$(_get media-title)
  [ -z "$title" ] && { _warn "nothing playing"; return; }
  pos=$(_get time-pos | awk '{printf "%d:%02d",$1/60,$1%60}' 2>/dev/null)
  dur=$(_get duration   | awk '{printf "%d:%02d",$1/60,$1%60}' 2>/dev/null)
  paused=$(_get pause)
  speed=$(_get speed | awk '{printf "%.2f",$1}')
  local icon="â–¶"; [ "$paused" = "true" ] && icon="â¸"
  local pl_pos; pl_pos=$(_get playlist-playing-pos)
  local pl_count; pl_count=$(_cmd '{"command":["get_property","playlist"]}' | "$JQ" '.data|length' 2>/dev/null)
  echo ""
  echo "  ${icon}  ${Y}${title}${X}"
  echo "  ${W}${pos}${X} / ${W}${dur}${X}   speed: ${speed}x   queue: $((pl_pos+1))/${pl_count:-?}"
  echo ""
}

# v5-F + v5-K â€” do_bar: cursor always restored; single jq pass per frame
do_bar() {
  _need
  local title; title=$(_get media-title)
  [ -z "$title" ] && { _warn "nothing playing"; return; }

  tput civis 2>/dev/null

  local _m_bar_cleanup_done=0
  _m_bar_cleanup() {
    if [[ $_m_bar_cleanup_done -eq 0 ]]; then
      _m_bar_cleanup_done=1
      printf '\n\n\n'
      tput cnorm 2>/dev/null
    fi
  }
  trap '_m_bar_cleanup' INT TERM

  local tw; tw=$(tput cols 2>/dev/null || echo 80)
  local bar_w=$(( tw - 24 ))
  (( bar_w < 10 )) && bar_w=10

  while true; do
    # v5-K â€” single jq parse pass for all bar properties (was 9 forks)
    local raw_props
    raw_props=$(_cmd '{"command":["get_property_list",["time-pos","duration","pause","speed","media-title","loop-playlist","loop-file","volume","playlist-playing-pos"]]}' 2>/dev/null)

    local pos dur paused speed title2 repeat loop_one vol pl_pos
    if echo "$raw_props" | "$JQ" -e '.data' >/dev/null 2>&1; then
      # Single jq invocation extracts all fields at once
      local parsed
      parsed=$(echo "$raw_props" | "$JQ" -r '
        .data |
        [
          (.["time-pos"]          // ""),
          (.["duration"]          // ""),
          (.["pause"]             // "false"),
          (.["speed"]             // "1"),
          (.["media-title"]       // ""),
          (.["loop-playlist"]     // "no"),
          (.["loop-file"]         // "no"),
          (.["volume"]            // "80"),
          (.["playlist-playing-pos"] // "0")
        ] | @tsv' 2>/dev/null)
      IFS=$'\t' read -r pos dur paused speed title2 repeat loop_one vol pl_pos <<< "$parsed"
    else
      pos=$(_get time-pos); dur=$(_get duration); paused=$(_get pause)
      speed=$(_get speed); title2=$(_get media-title); repeat=$(_get loop-playlist)
      loop_one=$(_get loop-file); vol=$(_get volume | awk '{printf "%.0f",$1}')
    fi

    speed=$(echo "$speed" | awk '{printf "%.2f",$1}')
    vol=$(echo "$vol" | awk '{printf "%.0f",$1}')

    # v5-F: break on empty pos/dur, but cleanup runs after loop (not just trap)
    [ -z "$pos" ] || [ -z "$dur" ] && break

    local pos_i dur_i
    pos_i=$(printf '%.0f' "$pos" 2>/dev/null || echo 0)
    dur_i=$(printf '%.0f' "$dur" 2>/dev/null || echo 1)
    (( dur_i < 1 )) && dur_i=1

    local pct=$(( pos_i * 100 / dur_i ))
    local filled=$(( pos_i * bar_w / dur_i ))
    local empty=$(( bar_w - filled ))
    (( filled < 0 )) && filled=0
    (( empty  < 0 )) && empty=0

    local pos_fmt; pos_fmt=$(awk "BEGIN{printf \"%d:%02d\", $pos_i/60, $pos_i%60}")
    local dur_fmt; dur_fmt=$(awk "BEGIN{printf \"%d:%02d\", $dur_i/60, $dur_i%60}")
    local rem_i=$(( dur_i - pos_i ))
    local rem_fmt; rem_fmt=$(awk "BEGIN{printf \"-%d:%02d\", $rem_i/60, $rem_i%60}")

    local icon="â–¶"; [ "$paused" = "true" ] && icon="â¸"
    local rep_icon=""
    [[ "$loop_one" != "no" && -n "$loop_one" ]] && rep_icon=" ðŸ”‚"
    [[ "$repeat"   != "no" && -n "$repeat"   ]] && rep_icon=" ðŸ”"

    local bar_filled bar_empty
    bar_filled=$(printf '%*s' "$filled" '' | tr ' ' 'â”')
    bar_empty=$(printf '%*s'  "$empty"  '' | tr ' ' 'â”€')

    printf '\r\e[2K'
    printf "\e[0;36m  ${icon}  \e[1;37m%.${tw}s\e[0m" "${title2}${rep_icon}"
    printf '\n\r\e[2K'
    printf "  \e[0;36m%s\e[0m\e[2m%s\e[0m  \e[0;33m%s\e[0m / \e[0;37m%s\e[0m  \e[2m(%s)\e[0m" \
      "$bar_filled" "$bar_empty" "$pos_fmt" "$dur_fmt" "$rem_fmt"
    printf '\n\r\e[2K'
    printf "  \e[2mspd:%sx  vol:%s%%  %d%%  p=pause  n/b=skip  ,/.=seek  +/-=vol  r=rpt  l=lyrics  q=quit\e[0m" \
      "$speed" "$vol" "$pct"
    printf '\e[2A'

    local key
    if read -r -s -k1 -t 0.5 key 2>/dev/null; then
      case "$key" in
        q|Q|$'\e') break ;;
        p) _silent '{"command":["cycle","pause"]}' ;;
        n) _silent '{"command":["playlist-next"]}'; sleep 0.4; (_autodj_check) & disown $! 2>/dev/null ;;
        b) _silent '{"command":["playlist-prev"]}'; sleep 0.4 ;;
        .) _silent '{"command":["seek","10","relative"]}' ;;
        ,) _silent '{"command":["seek","-10","relative"]}' ;;
        +) _silent "{\"command\":[\"add\",\"volume\",${VOLUME_STEP}]}" ;;
        -) _silent "{\"command\":[\"add\",\"volume\",-${VOLUME_STEP}]}" ;;
        r) _silent '{"command":["cycle","loop-playlist"]}' ;;
        1) _silent '{"command":["cycle","loop-file"]}' ;;
        l) printf '\n\n\n'; tput cnorm 2>/dev/null; _m_bar_cleanup_done=1; do_lyrics; return ;;
      esac
    fi
  done

  # v5-F: always cleanup after loop exit, not just on signal
  _m_bar_cleanup
  trap - INT TERM
}

do_scrub() {
  _need
  local title pos dur
  title=$(_get media-title)
  [ -z "$title" ] && { _warn "nothing playing"; return; }
  dur=$(_get duration)
  pos=$(_get time-pos)
  [ -z "$dur" ] && { _warn "duration unavailable (still buffering?)"; return; }

  local dur_i; dur_i=$(printf '%.0f' "$dur")
  local pos_i; pos_i=$(printf '%.0f' "${pos:-0}")
  (( dur_i < 1 )) && { _warn "track too short to scrub"; return; }

  local step=5
  (( dur_i / step > 500 )) && step=$(( dur_i / 500 + 1 ))

  local lines=()
  local t=0
  while (( t <= dur_i )); do
    local mm ss pct bar_fill bar_empty filled_w empty_w
    mm=$(( t / 60 )); ss=$(( t % 60 ))
    pct=$(( t * 100 / dur_i ))
    filled_w=$(( pct * 30 / 100 ))
    empty_w=$(( 30 - filled_w ))
    bar_fill=$(printf '%*s' "$filled_w" '' | tr ' ' 'â–ˆ')
    bar_empty=$(printf '%*s' "$empty_w" '' | tr ' ' 'â–‘')
    local marker="  "
    (( t >= pos_i - step/2 && t <= pos_i + step/2 )) && marker="â–¶ "
    lines+=("$(printf '%s%02d:%02d  [%s%s]  %3d%%' "$marker" "$mm" "$ss" "$bar_fill" "$bar_empty" "$pct")")
    t=$(( t + step ))
  done

  local chosen
  chosen=$(printf '%s\n' "${lines[@]}" | "$FZF" \
    --height 70% --reverse \
    --prompt "â±  scrub > " \
    --header "â–¶ marks current pos Â· ENTER to jump Â· ESC cancel" \
    --no-sort)

  [ -z "$chosen" ] && { _warn "cancelled"; return; }

  local ts; ts=$(echo "$chosen" | grep -oE '[0-9]+:[0-9]{2}' | head -1)
  [ -z "$ts" ] && { _err "could not parse timestamp"; return 1; }

  local m s target_secs
  m=$(echo "$ts" | cut -d: -f1 | sed 's/^0*//'); m=${m:-0}
  s=$(echo "$ts" | cut -d: -f2 | sed 's/^0*//'); s=${s:-0}
  target_secs=$(( m * 60 + s ))

  _silent "{\"command\":[\"seek\",\"$target_secs\",\"absolute\"]}"
  sleep 0.1
  local new_pos; new_pos=$(_get time-pos | awk '{printf "%d:%02d",$1/60,$1%60}')
  _ok "jumped to ${new_pos}  /  $(awk "BEGIN{printf \"%d:%02d\",$dur_i/60,$dur_i%60}")"
}

do_queue() {
  _need
  local pl current_idx n
  pl=$(_cmd '{"command":["get_property","playlist"]}')
  n=$(echo "$pl" | "$JQ" '.data|length' 2>/dev/null)
  current_idx=$(_get playlist-playing-pos)
  [ -z "$n" ] || [ "$n" = "0" ] && { _warn "queue empty"; return; }
  echo ""
  echo "  ${C}queue â€” ${n} tracks${X}"
  echo ""
  echo "$pl" | "$JQ" -r '.data | to_entries[] | [(.key|tostring), (.value.title // .value.filename)] | @tsv' 2>/dev/null \
    | while IFS=$'\t' read -r idx title; do
        if [ "$idx" = "$current_idx" ]; then
          echo "  ${G}â–¶ $((idx+1)). ${title}${X}"
        else
          echo "    $((idx+1)). ${title}"
        fi
      done
  echo ""
}

do_queue_move() {
  _need
  [[ -z "${1:-}" || -z "${2:-}" ]] && { _err "usage: m qmove <from_pos> <to_pos>  (1-based)"; return 1; }
  local from=$(( $1 - 1 )) to=$(( $2 - 1 ))
  _silent "{\"command\":[\"playlist-move\",${from},${to}]}"
  _ok "moved track $1 â†’ position $2"
}

do_queue_remove() {
  _need
  [[ -z "${1:-}" ]] && { _err "usage: m qrm <pos>  (1-based)"; return 1; }
  local pos=$(( $1 - 1 ))
  _silent "{\"command\":[\"playlist-remove\",${pos}]}"
  _ok "removed track $1 from queue"
}

do_status() {
  if [ ! -S "$SOCKET" ]; then
    echo ""
    echo "  ${R}â— stopped${X}   run: m start"
    echo ""
    return
  fi
  local title paused vol speed
  title=$(_get media-title)
  paused=$(_get pause)
  vol=$(_get volume | awk '{printf "%.0f",$1}')
  speed=$(_get speed | awk '{printf "%.2f",$1}')
  local pl_count; pl_count=$(_cmd '{"command":["get_property","playlist"]}' | "$JQ" '.data|length' 2>/dev/null)
  local repeat; repeat=$(_get loop-playlist)
  local loop_one; loop_one=$(_get loop-file)
  echo ""
  printf "  ${G}â— running${X}   vol:%s%%   speed:%sx   queue:%s tracks\n" "$vol" "$speed" "${pl_count:-0}"

  _txt_state_read
  if [ -n "$TXT_ACTIVE_FILE" ]; then
    _txt_read_lines "$TXT_ACTIVE_FILE"
    printf "  ${C}txt:${X} %s  [%s/%s]\n" "$(basename "$TXT_ACTIVE_FILE" .txt)" \
      "$(( TXT_ACTIVE_IDX + 1 ))" "${#TXT_LINES[@]}"
  fi

  local timer_file="$DATA_DIR/sleep_timer_pid"
  if [[ -f "$timer_file" ]]; then
    local tpid; tpid=$(cat "$timer_file" 2>/dev/null)
    [[ -n "$tpid" ]] && kill -0 "$tpid" 2>/dev/null && printf "  ${Y}â²  sleep timer active${X}\n"
  fi

  [[ -f "$AUTODJ_FILE" ]] && printf "  ${M}ðŸ¤– Auto-DJ active${X}\n"
  [[ "$repeat"   != "no" && -n "$repeat"   ]] && printf "  ${Y}ðŸ” repeat-playlist on${X}\n"
  [[ "$loop_one" != "no" && -n "$loop_one" ]] && printf "  ${Y}ðŸ”‚ repeat-one on${X}\n"
  if [ -n "$title" ]; then
    local pos dur
    pos=$(_get time-pos | awk '{printf "%d:%02d",$1/60,$1%60}' 2>/dev/null)
    dur=$(_get duration   | awk '{printf "%d:%02d",$1/60,$1%60}' 2>/dev/null)
    [ "$paused" = "true" ] \
      && echo "  ${Y}â¸  ${title}${X}   ${pos}/${dur}" \
      || echo "  ${G}â–¶  ${title}${X}   ${pos}/${dur}"
  else
    echo "  ${W}idle â€” queue something with: m \"song name\"${X}"
  fi
  echo ""
}

# â”€â”€ like / love â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
do_like() {
  _need
  local title url clean
  title=$(_get media-title)
  url=$(_get path)
  [ -z "$url" ] && { _warn "nothing playing"; return; }
  clean=$(_clean_url "$url")
  if grep -qF "$clean" "$LIKES_FILE" 2>/dev/null; then
    _warn "already liked: $title"
    return
  fi
  printf '%s\t%s\t%s\n' "$(date '+%Y-%m-%d %H:%M')" "$title" "$clean" >> "$LIKES_FILE"
  _ok "â¤  liked: ${title}"
}

do_unlike() {
  [ -s "$LIKES_FILE" ] || { _warn "no likes yet"; return; }
  local line
  line=$("$FZF" \
    --height 50% --reverse \
    --prompt "ðŸ’” unlike > " \
    --header "ENTER to remove Â· ESC cancel" \
    --with-nth=2 --delimiter=$'\t' < "$LIKES_FILE")
  [ -z "$line" ] && { _warn "cancelled"; return; }
  local tmpf; tmpf=$(mktemp "$LIKES_FILE.XXXXXX")
  grep -vF "$line" "$LIKES_FILE" > "$tmpf" && mv "$tmpf" "$LIKES_FILE" || rm -f "$tmpf"
  _ok "removed from likes"
}

do_likes() {
  [ -s "$LIKES_FILE" ] || { _warn "no likes yet â€” use: m like"; return; }
  echo ""
  echo "  ${M}â¤  liked tracks${X}"
  echo ""
  awk -F'\t' '{print NR". "$2}' "$LIKES_FILE" | sed 's/^/  /'
  echo ""
}

do_love() {
  _need
  [ -s "$LIKES_FILE" ] || { _warn "no likes yet â€” use: m like while playing"; return; }
  local line; line=$(_shuf1 "$LIKES_FILE")
  [ -z "$line" ] && { _warn "likes file empty"; return; }
  local url title
  url=$(printf '%s' "$line" | awk -F'\t' '{print $3}')
  title=$(printf '%s' "$line" | awk -F'\t' '{print $2}')
  _start
  _silent '{"command":["playlist-clear"]}'
  _ipc_loadfile "$url" "replace"
  local actual_title; actual_title=$(_wait_prop media-title 30)
  _ok "â¤  â–¶  ${actual_title:-$title}"
}

do_likes_play() {
  _need
  [ -s "$LIKES_FILE" ] || { _warn "no likes yet"; return; }
  local line
  line=$("$FZF" \
    --height 50% --reverse \
    --prompt "â¤ play liked > " \
    --header "ENTER play Â· ESC cancel" \
    --with-nth=2 --delimiter=$'\t' < "$LIKES_FILE")
  [ -z "$line" ] && { _warn "cancelled"; return; }
  local url; url=$(printf '%s' "$line" | awk -F'\t' '{print $3}')
  _silent '{"command":["playlist-clear"]}'
  _ipc_loadfile "$url" "replace"
  local actual_title; actual_title=$(_wait_prop media-title 30)
  _ok "â–¶  ${actual_title:-playing}"
}

# â”€â”€ history â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
do_history() {
  [ -s "$HISTORY_FILE" ] || { _warn "no history yet"; return; }
  local line url
  line=$(_tac "$HISTORY_FILE" | "$FZF" \
    --height 60% --reverse \
    --prompt "ðŸ•‘ history > " \
    --header "ENTER replay Â· ESC cancel" \
    --with-nth=1,2 --delimiter=$'\t' \
    --preview 'echo {} | awk -F"\t" "{printf \"Date:  %s\nTitle: %s\nURL:   %s\n\",\$1,\$2,\$3}"' \
    --preview-window=down:3:wrap)
  [ -z "$line" ] && { _warn "cancelled"; return; }
  url=$(printf '%s' "$line" | awk -F'\t' '{print $3}')
  [ -z "$url" ] && { _err "could not extract URL from history entry"; return 1; }
  _start
  _silent '{"command":["playlist-clear"]}'
  _ipc_loadfile "$url" "replace"
  local title; title=$(_wait_prop media-title 30)
  _ok "â–¶  ${title:-playing}"
}

do_history_clear() {
  printf "${Y}Clear all history? [y/N] ${X}"
  read -r ans
  [[ "$ans" =~ ^[Yy]$ ]] || { _warn "cancelled"; return; }
  > "$HISTORY_FILE"
  _ok "history cleared"
}

# â”€â”€ playlists â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
do_save() {
  _need
  [ -z "${1:-}" ] && { _err "usage: m save <n>"; return 1; }
  local name="$1"
  name=$(printf '%s' "$name" | tr ' ' '_' | tr -cd '[:alnum:]_-')
  [ -z "$name" ] && { _err "invalid playlist name"; return 1; }
  local file="$PLAYLIST_DIR/${name}.m3u"
  local tmpf; tmpf=$(mktemp "$PLAYLIST_DIR/${name}.XXXXXX")
  local count=0
  local raw_playlist; raw_playlist=$(_cmd '{"command":["get_property","playlist"]}')
  local urls; urls=$(echo "$raw_playlist" | "$JQ" -r '.data[].filename' 2>/dev/null)
  if [[ -z "$urls" ]]; then
    rm -f "$tmpf"; _err "queue is empty â€” nothing to save"; return 1
  fi
  while IFS= read -r url; do
    [ -z "$url" ] && continue
    printf '%s\n' "$(_clean_url "$url")" >> "$tmpf"
    count=$(( count + 1 ))
  done <<< "$urls"
  if [[ $count -eq 0 ]]; then
    rm -f "$tmpf"; _err "queue is empty â€” nothing to save"; return 1
  fi
  mv "$tmpf" "$file"
  _ok "saved: ${name}  (${count} tracks)"
}

do_load() {
  [ -z "${1:-}" ] && { _err "usage: m load <n>"; return 1; }
  local f="$PLAYLIST_DIR/${1}.m3u"
  [ -f "$f" ] || { _err "playlist not found: $1"; return 1; }
  _start
  _silent '{"command":["playlist-clear"]}'
  local _existing_urls
  _existing_urls=$(_cmd '{"command":["get_property","playlist"]}' \
    | "$JQ" -r '.data[].filename // empty' 2>/dev/null || echo "")
  local count=0
  while IFS= read -r line; do
    [[ -z "$line" || "$line" == \#* ]] && continue
    if echo "$_existing_urls" | grep -qF "$line" 2>/dev/null; then
      _warn "skipping duplicate: $(basename "$line")"
      continue
    fi
    _ipc_loadfile "$line" "append-play"
    _existing_urls="${_existing_urls}"$'\n'"${line}"
    count=$(( count + 1 ))
  done < "$f"
  _ok "loaded: $1  (${count} tracks)"
  _info "first track buffering... use: m now"
  _queue_snapshot
}

do_playlists() {
  echo ""
  echo "  ${C}saved playlists:${X}"
  local found=0
  for f in "$PLAYLIST_DIR"/*.m3u(N); do
    local name; name=$(basename "$f" .m3u)
    local count; count=$(grep -cvE '^\s*(#|$)' "$f" 2>/dev/null || echo 0)
    echo "  âˆ™ ${W}${name}${X}  (${count} tracks)"
    found=1
  done
  [ $found -eq 0 ] && echo "  (none yet â€” use: m save <n>)"
  echo ""
}

do_playlist_del() {
  [ -z "${1:-}" ] && { _err "usage: m pldel <n>"; return 1; }
  local f="$PLAYLIST_DIR/${1}.m3u"
  [ -f "$f" ] || { _err "not found: $1"; return 1; }
  printf "${Y}Delete playlist '%s'? [y/N] ${X}" "$1"
  read -r ans
  [[ "$ans" =~ ^[Yy]$ ]] || { _warn "cancelled"; return; }
  rm "$f"
  _ok "deleted playlist: $1"
}

# â”€â”€ download â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
do_dl() {
  [ -z "${1:-}" ] && { _err "usage: m dl \"song query\""; return 1; }
  _info "searching to download..."
  local url; url=$(_pick "$1") || return 1
  [ -z "$url" ] && { _warn "cancelled"; return; }
  _info "downloading to $DOWNLOADS_DIR ..."
  echo ""
  "$YTDLP" "$url" \
    --extract-audio \
    --audio-format mp3 \
    --audio-quality 0 \
    --embed-thumbnail \
    --add-metadata \
    --embed-metadata \
    --output "$DOWNLOADS_DIR/%(title)s.%(ext)s" \
    --no-playlist \
    --progress \
    --console-title=no \
    --no-warnings
  local rc=$?
  echo ""
  if [[ $rc -ne 0 ]]; then
    _err "download failed (yt-dlp exit $rc) â€” check: m log"
    return 1
  fi
  _ok "download complete â†’ $DOWNLOADS_DIR"
}

do_dl_list() {
  echo ""
  echo "  ${C}downloads:${X}  $DOWNLOADS_DIR"
  echo ""
  local found=0
  for f in "$DOWNLOADS_DIR"/*.mp3(N) "$DOWNLOADS_DIR"/*.m4a(N) "$DOWNLOADS_DIR"/*.opus(N); do
    echo "  âˆ™ $(basename "$f")"
    found=1
  done
  [[ $found -eq 0 ]] && echo "  (none yet â€” use: m dl \"song name\")"
  echo ""
}

# â”€â”€ import YouTube playlist â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
do_import() {
  [ -z "${1:-}" ] && { _err "usage: m import \"https://youtube.com/playlist?list=...\""; return 1; }
  _info "fetching playlist metadata (this may take a moment)..."
  local tmpf; tmpf=$(mktemp "$PLAYLIST_DIR/import.XXXXXX")
  "$YTDLP" "$1" \
    --flat-playlist \
    --print "%(webpage_url)s" \
    --no-warnings 2>/dev/null > "$tmpf"
  local count; count=$(wc -l < "$tmpf" | tr -d ' ')
  if [[ $count -eq 0 ]]; then
    rm -f "$tmpf"
    _err "no tracks found â€” is the URL correct and the playlist public?"
    return 1
  fi
  printf "${C}Save as playlist name: ${X}"
  read -r pname
  pname=$(printf '%s' "$pname" | tr ' ' '_' | tr -cd '[:alnum:]_-')
  [ -z "$pname" ] && { rm -f "$tmpf"; _err "invalid name"; return 1; }
  if [[ -f "$PLAYLIST_DIR/${pname}.m3u" ]]; then
    local existing_count; existing_count=$(grep -cvE '^\s*(#|$)' "$PLAYLIST_DIR/${pname}.m3u" 2>/dev/null || echo 0)
    printf "${Y}Playlist '%s' already exists (%s tracks). Overwrite? [y/N] ${X}" "$pname" "$existing_count"
    local ans; read -r ans
    if [[ ! "$ans" =~ ^[Yy]$ ]]; then
      rm -f "$tmpf"; _warn "import cancelled"; return 1
    fi
  fi
  mv "$tmpf" "$PLAYLIST_DIR/${pname}.m3u"
  _ok "imported: ${pname}  (${count} tracks)  â†’  m load ${pname}"
}

# â”€â”€ v5-P â€” Real-time synced lyrics from lrclib.net â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
do_lyrics() {
  _need
  [[ -z "$CURL" || ! -x "$CURL" ]] && { _err "curl required for lyrics"; return 1; }
  [[ "$LYRICS_ENABLED" != "1" ]] && { _warn "lyrics disabled â€” set LYRICS_ENABLED=1 in config"; return; }

  local title; title=$(_get media-title)
  [ -z "$title" ] && { _warn "nothing playing"; return; }

  _info "fetching lyrics for: $title"

  # Try to split "Artist - Title" format
  local artist track
  if echo "$title" | grep -q ' - '; then
    artist=$(echo "$title" | cut -d'-' -f1 | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
    track=$(echo "$title"  | cut -d'-' -f2- | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
  else
    artist=""; track="$title"
  fi

  local enc_track; enc_track=$(printf '%s' "$track" | "$JQ" -Rr '@uri' 2>/dev/null)
  local enc_artist; enc_artist=$(printf '%s' "$artist" | "$JQ" -Rr '@uri' 2>/dev/null)

  # lrclib.net API â€” free, no key required
  local api_url="https://lrclib.net/api/search?q=${enc_track}"
  [[ -n "$enc_artist" ]] && api_url="${api_url}&artist_name=${enc_artist}"

  local resp; resp=$("$CURL" -sf --max-time 8 "$api_url" 2>/dev/null) || {
    _err "could not reach lrclib.net â€” check connection"; return 1
  }

  # Try synced lyrics first, fall back to plain
  local lrc; lrc=$(echo "$resp" | "$JQ" -r '.[0].syncedLyrics // empty' 2>/dev/null)
  local has_sync=1
  if [[ -z "$lrc" ]]; then
    lrc=$(echo "$resp" | "$JQ" -r '.[0].plainLyrics // empty' 2>/dev/null)
    has_sync=0
  fi

  if [[ -z "$lrc" ]]; then
    _warn "no lyrics found for: $title"
    return
  fi

  if [[ "$has_sync" -eq 0 ]]; then
    # Plain lyrics â€” just display with pager
    echo ""
    echo "  ${C}Lyrics: ${title}${X}  ${DIM}(plain â€” no sync)${X}"
    echo ""
    echo "$lrc" | sed 's/^/  /'
    echo ""
    return
  fi

  # Synced lyrics: parse LRC format [MM:SS.xx] line
  # Display with real-time highlighting based on mpv time-pos
  tput civis 2>/dev/null
  local cleanup_done=0
  _lyrics_cleanup() {
    [[ $cleanup_done -eq 0 ]] && { cleanup_done=1; tput cnorm 2>/dev/null; printf '\n'; }
  }
  trap '_lyrics_cleanup' INT TERM EXIT

  echo ""
  echo "  ${C}â™ª ${title}${X}  ${DIM}(synced â€” q to exit)${X}"
  echo ""

  # Parse LRC into arrays: timestamps (seconds) and lines
  local -a lrc_times lrc_lines
  local prev_line
  while IFS= read -r line; do
    if echo "$line" | grep -qE '^\[[0-9]+:[0-9]+\.[0-9]+\]'; then
      local ts; ts=$(echo "$line" | grep -oE '^\[[0-9]+:[0-9]+\.[0-9]+\]' | tr -d '[]')
      local mm ss
      mm=$(echo "$ts" | cut -d: -f1 | sed 's/^0*//' ); mm=${mm:-0}
      ss=$(echo "$ts" | cut -d: -f2)
      local total_s; total_s=$(awk "BEGIN{printf \"%d\", $mm*60+$ss}")
      local ltext; ltext=$(echo "$line" | sed 's/^\[[^]]*\]//' | sed 's/^[[:space:]]*//')
      lrc_times+=("$total_s")
      lrc_lines+=("$ltext")
    fi
  done <<< "$lrc"

  local total=${#lrc_times[@]}
  (( total == 0 )) && { _warn "could not parse synced lyrics"; tput cnorm 2>/dev/null; return; }

  local last_idx=-1
  local tw; tw=$(tput cols 2>/dev/null || echo 80)

  while true; do
    local pos; pos=$(_get time-pos 2>/dev/null)
    [[ -z "$pos" ]] && break
    local pos_i; pos_i=$(printf '%.0f' "$pos" 2>/dev/null || echo 0)

    # Find current lyric line
    local cur_idx=0
    local i=1
    while [[ $i -le $total ]]; do
      if (( lrc_times[$i] <= pos_i )); then
        cur_idx=$i
      fi
      i=$(( i + 1 ))
    done

    if (( cur_idx != last_idx )); then
      last_idx=$cur_idx
      clear 2>/dev/null || printf '\033[2J\033[H'
      echo ""
      echo "  ${C}â™ª ${title}${X}  ${DIM}(synced â€” q to exit)${X}"
      echo ""

      # Show context: 3 before, current, 3 after
      local ctx_start=$(( cur_idx - 3 ))
      local ctx_end=$(( cur_idx + 4 ))
      (( ctx_start < 1 )) && ctx_start=1
      (( ctx_end > total )) && ctx_end=$total

      local j=$ctx_start
      while (( j <= ctx_end )); do
        local lyric_line="${lrc_lines[$j]}"
        if (( j == cur_idx )); then
          printf "  ${G}${BOLD}â–¶ %-${tw}s${X}\n" "$lyric_line"
        else
          printf "  ${DIM}  %-${tw}s${X}\n" "$lyric_line"
        fi
        j=$(( j + 1 ))
      done
      echo ""
      printf "  ${DIM}[%d:%02d]  q=quit  bar=back to progress bar${X}\n" \
        "$(( pos_i / 60 ))" "$(( pos_i % 60 ))"
    fi

    local key
    if read -r -s -k1 -t 0.3 key 2>/dev/null; then
      [[ "$key" == "q" || "$key" == "Q" || "$key" == $'\e' ]] && break
    fi
  done

  _lyrics_cleanup
  trap - INT TERM EXIT
}

# â”€â”€ v5-O â€” Terminal album art via chafa â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
do_art() {
  _need
  local url; url=$(_get path)
  [ -z "$url" ] && { _warn "nothing playing"; return; }

  if [[ -z "$CHAFA" || ! -x "$CHAFA" ]]; then
    _warn "chafa not installed â€” install with: brew install chafa  or  apt install chafa"
    return
  fi
  if [[ -z "$CURL" || ! -x "$CURL" ]]; then
    _warn "curl required for album art"; return
  fi

  local title; title=$(_get media-title)
  local vid; vid=$(echo "$url" | grep -oE '[?&]v=([A-Za-z0-9_-]{11})' | head -1 | cut -d= -f2)

  if [[ -z "$vid" ]]; then
    vid=$(echo "$url" | grep -oE '/shorts/([A-Za-z0-9_-]{11})' | head -1 | grep -oE '[A-Za-z0-9_-]{11}$')
  fi

  if [[ -z "$vid" ]]; then
    _warn "album art only available for YouTube tracks"
    return
  fi

  local thumb_url="https://img.youtube.com/vi/${vid}/maxresdefault.jpg"
  local thumb_file; thumb_file=$(mktemp "/tmp/m_art_XXXXXX.jpg")

  _info "fetching album art..."
  if ! "$CURL" -sf --max-time 8 "$thumb_url" -o "$thumb_file" 2>/dev/null; then
    # Fall back to lower resolution
    thumb_url="https://img.youtube.com/vi/${vid}/hqdefault.jpg"
    "$CURL" -sf --max-time 8 "$thumb_url" -o "$thumb_file" 2>/dev/null || {
      rm -f "$thumb_file"; _err "could not fetch album art"; return 1
    }
  fi

  echo ""
  echo "  ${C}â™ª ${title}${X}"
  echo ""
  "$CHAFA" --size "$(tput cols)x20" "$thumb_file" 2>/dev/null
  echo ""
  rm -f "$thumb_file"
}

# â”€â”€ v5-Q â€” Unified TUI dashboard â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
do_ui() {
  if ! command -v tmux >/dev/null 2>&1; then
    _warn "tmux not installed â€” unified UI requires tmux"
    _info "falling back to m bar..."
    do_bar
    return
  fi

  _need

  local session="m_ui_$$"
  local script_path="$0"

  tmux new-session -d -s "$session" -x "$(tput cols)" -y "$(tput lines)" 2>/dev/null || {
    _warn "could not create tmux session"; do_bar; return
  }

  # Layout: left=queue (30%), right-top=art (if chafa), right-bottom=bar
  tmux split-window -h -l "30%" -t "$session"
  tmux split-window -v -t "${session}:0.1"

  # Pane 0 (left): queue â€” auto-refresh every 3s
  tmux send-keys -t "${session}:0.0" \
    "watch -n 3 '\"$script_path\" queue 2>/dev/null'" Enter

  # Pane 1 (top-right): album art
  if [[ -n "$CHAFA" && -x "$CHAFA" ]]; then
    tmux send-keys -t "${session}:0.1" \
      "while true; do \"$script_path\" art 2>/dev/null; sleep 10; done" Enter
  else
    tmux send-keys -t "${session}:0.1" \
      "\"$script_path\" now" Enter
  fi

  # Pane 2 (bottom-right): live progress bar
  tmux send-keys -t "${session}:0.2" "\"$script_path\" bar" Enter

  tmux attach-session -t "$session"

  # Cleanup on exit
  tmux kill-session -t "$session" 2>/dev/null
}

# â”€â”€ v5-T â€” Bookmarks: named snapshots of queue + position â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
do_bookmark() {
  _need
  local title; title=$(_get media-title)
  [ -z "$title" ] && { _warn "nothing playing"; return; }

  local pos; pos=$(_get time-pos | awk '{printf "%d:%02d",$1/60,$1%60}' 2>/dev/null)
  local url; url=$(_get path)

  local name="${1:-}"
  if [[ -z "$name" ]]; then
    name="$(date '+%Y%m%d_%H%M')_${title:0:30}"
    name=$(printf '%s' "$name" | tr ' /' '_' | tr -cd '[:alnum:]_-')
  fi

  # Save queue snapshot with this name
  local bm_dir="$DATA_DIR/bookmarks_dir"
  mkdir -p "$bm_dir"
  _queue_snapshot
  cp "$QUEUE_SNAPSHOT" "$bm_dir/${name}.m3u" 2>/dev/null

  # Log the bookmark entry
  printf '%s\t%s\t%s\t%s\t%s\n' \
    "$(date '+%Y-%m-%d %H:%M')" "$name" "$title" "$pos" "$(_clean_url "$url")" \
    >> "$BOOKMARKS_FILE"

  _ok "ðŸ“Œ bookmark saved: ${name}  (${title} @ ${pos})"
}

do_bookmarks() {
  [ -s "$BOOKMARKS_FILE" ] || { _warn "no bookmarks yet â€” use: m bookmark"; return; }
  echo ""
  echo "  ${C}ðŸ“Œ bookmarks:${X}"
  echo ""
  awk -F'\t' '{printf "  âˆ™ %s  |  %s @ %s\n", $2, $3, $4}' "$BOOKMARKS_FILE"
  echo ""
}

do_bookmark_load() {
  [ -s "$BOOKMARKS_FILE" ] || { _warn "no bookmarks yet"; return; }
  local line
  line=$("$FZF" \
    --height 50% --reverse \
    --prompt "ðŸ“Œ bookmark > " \
    --header "ENTER to restore Â· ESC cancel" \
    --with-nth=2,3,4 --delimiter=$'\t' < "$BOOKMARKS_FILE")
  [ -z "$line" ] && { _warn "cancelled"; return; }

  local bm_name; bm_name=$(printf '%s' "$line" | awk -F'\t' '{print $2}')
  local bm_pos; bm_pos=$(printf '%s' "$line" | awk -F'\t' '{print $4}')
  local bm_dir="$DATA_DIR/bookmarks_dir"
  local bm_file="$bm_dir/${bm_name}.m3u"

  _start
  _silent '{"command":["playlist-clear"]}'

  if [[ -f "$bm_file" ]]; then
    while IFS= read -r url; do
      [ -z "$url" ] && continue
      _ipc_loadfile "$url" "append-play"
    done < "$bm_file"
    _ok "ðŸ“Œ restored queue from bookmark: $bm_name"
  else
    # Fallback: just play the URL
    local bm_url; bm_url=$(printf '%s' "$line" | awk -F'\t' '{print $5}')
    _ipc_loadfile "$bm_url" "replace"
    _ok "ðŸ“Œ restored track from bookmark: $bm_name"
  fi

  # Seek to saved position
  if [[ -n "$bm_pos" && "$bm_pos" != "0:00" ]]; then
    sleep 2  # wait for track to load
    local m s target_secs
    m=$(echo "$bm_pos" | cut -d: -f1 | sed 's/^0*//'); m=${m:-0}
    s=$(echo "$bm_pos" | cut -d: -f2 | sed 's/^0*//'); s=${s:-0}
    target_secs=$(( m * 60 + s ))
    _silent "{\"command\":[\"seek\",\"$target_secs\",\"absolute\"]}"
    _info "seeked to: $bm_pos"
  fi
}

# â”€â”€ v5-R â€” Auto-DJ toggle â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
do_autodj() {
  if [[ -f "$AUTODJ_FILE" ]]; then
    rm -f "$AUTODJ_FILE"
    AUTODJ_ENABLED=0
    _ok "ðŸ¤– Auto-DJ: OFF"
  else
    touch "$AUTODJ_FILE"
    AUTODJ_ENABLED=1
    _ok "ðŸ¤– Auto-DJ: ON  (queue will auto-refill from Last.fm/YouTube when empty)"
    [[ -z "$LASTFM_API_KEY" ]] && _warn "tip: set LASTFM_API_KEY in config for better recommendations"
  fi
}

# â”€â”€ txt playlist system â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
_txt_state_write() {
  local file="$1" idx="$2"
  printf '%s\t%s\n' "$file" "$idx" > "$TXT_STATE_FILE"
}

_txt_state_read() {
  TXT_ACTIVE_FILE=""
  TXT_ACTIVE_IDX=0
  [ -f "$TXT_STATE_FILE" ] || return
  TXT_ACTIVE_FILE=$(awk -F'\t' '{print $1}' "$TXT_STATE_FILE")
  TXT_ACTIVE_IDX=$(awk -F'\t' '{print $2}' "$TXT_STATE_FILE")
  [ -f "$TXT_ACTIVE_FILE" ] || { TXT_ACTIVE_FILE=""; TXT_ACTIVE_IDX=0; }
}

_txt_read_lines() {
  local f="$1"
  TXT_LINES=()
  while IFS= read -r line; do
    line="${line#"${line%%[! ]*}"}"
    line="${line%"${line##*[! ]}"}"
    [[ -z "$line" || "$line" == \#* ]] && continue
    TXT_LINES+=("$line")
  done < "$f"
}

_txt_resolve() {
  local arg="$1"
  [ -f "$arg" ] && { echo "$arg"; return; }
  [ -f "$TXTS_DIR/${arg}.txt" ] && { echo "$TXTS_DIR/${arg}.txt"; return; }
  [ -f "$TXTS_DIR/${arg}" ] && { echo "$TXTS_DIR/${arg}"; return; }
  echo ""
}

_txt_search_and_play_line() {
  local query="$1"
  local key="$CACHE_DIR/$(_cache_key "$query").cache"
  local results url

  local _txt_n="${SEARCH_RESULTS:-5}"
  (( _txt_n > 5 )) && _txt_n=5

  if [ -f "$key" ] && [ "$(_cache_age "$key")" -lt "$CACHE_TTL" ]; then
    results=$(cat "$key")
  else
    # v5-Z: use _do_search which has proper PIPESTATUS-equivalent error handling
    results=$(_do_search "$query" "$_txt_n") || return 1
    local valid_count; valid_count=$(echo "$results" | grep -cE 'https?://' 2>/dev/null || echo 0)
    [[ -n "$results" ]] && (( valid_count >= 1 )) && echo "$results" > "$key"
  fi

  [ -z "$results" ] && return 1
  url=$(echo "$results" | head -1 | awk -F ' \| ' '{print $NF}')
  echo "$url"
}

# v5-C â€” _txt_kill_bg_job: PID written atomically BEFORE disown
_txt_kill_bg_job() {
  local bg_pid_file="$DATA_DIR/txt_bg_pid"
  if [ -f "$bg_pid_file" ]; then
    local old_pid; old_pid=$(cat "$bg_pid_file" 2>/dev/null)
    if [ -n "$old_pid" ]; then
      kill -TERM -- "-$old_pid" 2>/dev/null || kill -TERM "$old_pid" 2>/dev/null
      sleep 0.2
      kill -0 "$old_pid" 2>/dev/null && kill -KILL "$old_pid" 2>/dev/null
    fi
    rm -f "$bg_pid_file"
  fi
  local cur_gen=0
  [ -f "$TXT_BG_GEN_FILE" ] && cur_gen=$(cat "$TXT_BG_GEN_FILE" 2>/dev/null || echo 0)
  echo $(( cur_gen + 1 )) > "$TXT_BG_GEN_FILE"
}

# v5-N â€” Parallel txt resolution: all lines resolved concurrently
do_txt() {
  local arg="${1:-}"
  local resume_flag="${2:-}"
  local chosen_file=""

  if [ -z "$arg" ]; then
    local files=("$TXTS_DIR"/*.txt(N))
    if [ ${#files[@]} -eq 0 ]; then
      _warn "no .txt files in $TXTS_DIR"
      _info "create one and drop it there â€” one song name per line"
      return
    fi
    local display=()
    for f in "${files[@]}"; do
      local n; n=$(grep -cvE '^\s*(#|$)' "$f" 2>/dev/null || echo 0)
      display+=("$(basename "$f" .txt)  (${n} songs)")
    done
    local picked
    picked=$(printf '%s\n' "${display[@]}" | "$FZF" \
      --height 50% --reverse \
      --prompt "ðŸ“„ txt playlist > " \
      --header "ENTER to load Â· ESC cancel")
    [ -z "$picked" ] && { _warn "cancelled"; return; }
    local fname; fname=$(echo "$picked" | awk '{print $1}')
    chosen_file="$TXTS_DIR/${fname}.txt"
  else
    chosen_file=$(_txt_resolve "$arg")
    [ -z "$chosen_file" ] && { _err "txt file not found: $arg  (looked in $TXTS_DIR)"; return 1; }
  fi

  _txt_read_lines "$chosen_file"
  [ ${#TXT_LINES[@]} -eq 0 ] && { _err "txt file is empty or has only comments: $chosen_file"; return 1; }

  _start

  # v5-U: --resume flag restores last position
  local start_idx=0
  if [[ "$resume_flag" == "--resume" || "$resume_flag" == "-r" ]]; then
    _txt_state_read
    if [[ "$TXT_ACTIVE_FILE" == "$chosen_file" && $TXT_ACTIVE_IDX -gt 0 ]]; then
      start_idx=$TXT_ACTIVE_IDX
      _info "resuming txt playlist at position $((start_idx + 1))"
    fi
  fi

  local fname_display; fname_display=$(basename "$chosen_file" .txt)
  _info "loading txt playlist: ${fname_display}  (${#TXT_LINES[@]} songs)"

  _txt_kill_bg_job
  _txt_state_write "$chosen_file" "$start_idx"
  _silent '{"command":["playlist-clear"]}'

  # Play first (or resumed) track
  local first_query="${TXT_LINES[$(( start_idx + 1 ))]}"
  local first_url
  first_url=$(_txt_search_and_play_line "$first_query")
  if [ -z "$first_url" ]; then
    _warn "could not find: ${first_query} â€” skipping"
  else
    _ipc_loadfile "$first_url" "replace"
  fi

  # Capture variables for bg job
  local _bg_socat="$SOCAT" _bg_socket="$SOCKET" _bg_jq="$JQ"
  local _bg_ytdlp="$YTDLP" _bg_cache_dir="$CACHE_DIR" _bg_cache_ttl="$CACHE_TTL"
  local _bg_search_n="${SEARCH_RESULTS:-5}"
  (( _bg_search_n > 5 )) && _bg_search_n=5
  local _bg_gen; _bg_gen=$(cat "$TXT_BG_GEN_FILE" 2>/dev/null || echo 0)
  local _bg_gen_file="$TXT_BG_GEN_FILE"
  local _bg_youtube_api_key="$YOUTUBE_API_KEY"
  local _bg_invidious_host="$INVIDIOUS_HOST"
  local _bg_curl="$CURL"

  # v5-N â€” parallel resolution: spawn workers for all remaining tracks
  # Each worker resolves one track; they all append concurrently.
  # Generation counter prevents stale workers from appending.
  (
    local socat="$_bg_socat" socket="$_bg_socket" jq="$_bg_jq"
    local ytdlp="$_bg_ytdlp" cache_dir="$_bg_cache_dir" cache_ttl="$_bg_cache_ttl"
    local my_gen="$_bg_gen" gen_file="$_bg_gen_file"
    local search_n="$_bg_search_n"
    local yt_api_key="$_bg_youtube_api_key"
    local inv_host="$_bg_invidious_host"
    local curl_bin="$_bg_curl"
    local _user_for_cache="${USER:-$(id -un)}"

    _bg_search_one() {
      local query="$1"
      local key="${cache_dir}/$(printf '%s\0%s' "$_user_for_cache" "$query" \
        | md5sum 2>/dev/null | cut -c1-32 \
        || printf '%s\0%s' "$_user_for_cache" "$query" | md5 2>/dev/null \
        || printf '%s' "$query" | md5sum 2>/dev/null | cut -c1-32).cache"

      # Check cache first
      if [ -f "$key" ] && [ $(( $(date +%s) - $(stat -c%Y "$key" 2>/dev/null || stat -f%m "$key" 2>/dev/null || echo 0) )) -lt "$cache_ttl" ]; then
        cat "$key"; return 0
      fi

      local results=""

      # Try YouTube Data API v3
      if [[ -n "$yt_api_key" && -n "$curl_bin" && -x "$curl_bin" ]]; then
        local enc_q; enc_q=$(printf '%s' "$query" | "$jq" -Rr '@uri' 2>/dev/null)
        local api_resp
        api_resp=$("$curl_bin" -sf --max-time 8 \
          "https://www.googleapis.com/youtube/v3/search?part=snippet&type=video&videoCategoryId=10&maxResults=1&q=${enc_q}&key=${yt_api_key}" \
          2>/dev/null) || true
        if [[ -n "$api_resp" ]]; then
          local vid_id title_r
          vid_id=$(echo "$api_resp" | "$jq" -r '.items[0].id.videoId // empty' 2>/dev/null)
          title_r=$(echo "$api_resp" | "$jq" -r '.items[0].snippet.title // empty' 2>/dev/null)
          if [[ -n "$vid_id" ]]; then
            results="${title_r} |  | https://www.youtube.com/watch?v=${vid_id}"
          fi
        fi
      fi

      # Try Invidious
      if [[ -z "$results" && -n "$inv_host" && -n "$curl_bin" && -x "$curl_bin" ]]; then
        local enc_q; enc_q=$(printf '%s' "$query" | "$jq" -Rr '@uri' 2>/dev/null)
        local inv_resp
        inv_resp=$("$curl_bin" -sf --max-time 8 \
          "${inv_host}/api/v1/search?q=${enc_q}&type=video&fields=title,videoId&page=1" \
          2>/dev/null) || true
        if [[ -n "$inv_resp" ]]; then
          local vid_id title_r
          vid_id=$(echo "$inv_resp" | "$jq" -r '.[0].videoId // empty' 2>/dev/null)
          title_r=$(echo "$inv_resp" | "$jq" -r '.[0].title // empty' 2>/dev/null)
          if [[ -n "$vid_id" ]]; then
            results="${title_r} |  | https://www.youtube.com/watch?v=${vid_id}"
          fi
        fi
      fi

      # Fall back to yt-dlp
      if [[ -z "$results" ]]; then
        results=$("$ytdlp" "ytsearch${search_n}:${query}" \
          --print "%(title)s | %(duration_string)s | %(webpage_url)s" \
          --no-download --no-warnings 2>/dev/null | head -1)
      fi

      if [[ -n "$results" ]]; then
        echo "$results" > "$key"
        echo "$results"
      fi
    }

    # Spawn parallel workers for all tracks after the first
    local i=$(( start_idx + 2 ))
    local pids=()

    while [ $i -le ${#TXT_LINES[@]} ]; do
      # Check generation
      local cur_gen; cur_gen=$(cat "$gen_file" 2>/dev/null || echo 0)
      [ "$cur_gen" = "$my_gen" ] || exit 0

      local query="${TXT_LINES[$i]}"

      # v5-N: spawn worker for this track
      (
        local cur; cur=$(cat "$gen_file" 2>/dev/null || echo 0)
        [ "$cur" = "$my_gen" ] || exit 0

        local result; result=$(_bg_search_one "$query")
        [ -z "$result" ] && exit 0

        local url; url=$(echo "$result" | head -1 | awk -F ' \| ' '{print $NF}')
        [ -z "$url" ] && exit 0

        local json
        json=$("$jq" -cn --arg url "$url" '{"command":["loadfile",$url,"append"]}')
        echo "$json" | "$socat" - "$socket" >/dev/null 2>&1
      ) &
      pids+=($!)

      # Throttle: max 4 parallel workers to avoid rate limiting
      if (( ${#pids[@]} >= 4 )); then
        wait "${pids[1]}" 2>/dev/null
        pids=("${pids[@]:1}")
      fi

      i=$(( i + 1 ))
    done

    # Wait for remaining workers
    for pid in "${pids[@]}"; do
      wait "$pid" 2>/dev/null
    done
  ) &

  local bg_pid=$!
  # v5-C: write PID file atomically BEFORE disown (tempfile swap)
  local tmpf_pid; tmpf_pid=$(mktemp "$DATA_DIR/txt_bg_pid.XXXXXX")
  echo $bg_pid > "$tmpf_pid" && mv "$tmpf_pid" "$DATA_DIR/txt_bg_pid" || rm -f "$tmpf_pid"
  disown $bg_pid

  local title; title=$(_wait_prop media-title 30)
  _ok "â–¶  ${title:-${TXT_LINES[1]}}"
  _info "use: m txtnext (tn) / m txtprev (tp) to step through"
}

do_txtnext() {
  _need
  _txt_state_read
  [ -z "$TXT_ACTIVE_FILE" ] && { _err "no active txt playlist â€” start one with: m txt"; return 1; }
  _txt_read_lines "$TXT_ACTIVE_FILE"
  local total=${#TXT_LINES[@]}
  local next_idx=$(( TXT_ACTIVE_IDX + 1 ))
  if [ $next_idx -ge $total ]; then
    _warn "end of txt playlist: $(basename "$TXT_ACTIVE_FILE" .txt)  ($total songs)"
    return
  fi
  _txt_kill_bg_job
  _txt_state_write "$TXT_ACTIVE_FILE" "$next_idx"
  local query="${TXT_LINES[$(( next_idx + 1 ))]}"
  _info "searching: ${query}"
  local url; url=$(_txt_search_and_play_line "$query")
  [ -z "$url" ] && { _warn "could not find: $query"; return; }
  _silent '{"command":["playlist-clear"]}'
  _ipc_loadfile "$url" "replace"
  local title; title=$(_wait_prop media-title 20)
  _ok "â­  [$(( next_idx + 1 ))/${total}]  ${title:-$query}"
}

do_txtprev() {
  _need
  _txt_state_read
  [ -z "$TXT_ACTIVE_FILE" ] && { _err "no active txt playlist â€” start one with: m txt"; return 1; }
  _txt_read_lines "$TXT_ACTIVE_FILE"
  local total=${#TXT_LINES[@]}
  local prev_idx=$(( TXT_ACTIVE_IDX - 1 ))
  if [ $prev_idx -lt 0 ]; then
    _warn "already at start of txt playlist: $(basename "$TXT_ACTIVE_FILE" .txt)"
    return
  fi
  _txt_kill_bg_job
  _txt_state_write "$TXT_ACTIVE_FILE" "$prev_idx"
  local query="${TXT_LINES[$(( prev_idx + 1 ))]}"
  _info "searching: ${query}"
  local url; url=$(_txt_search_and_play_line "$query")
  [ -z "$url" ] && { _warn "could not find: $query"; return; }
  _silent '{"command":["playlist-clear"]}'
  _ipc_loadfile "$url" "replace"
  local title; title=$(_wait_prop media-title 20)
  _ok "â®  [$(( prev_idx + 1 ))/${total}]  ${title:-$query}"
}

do_txtnow() {
  _txt_state_read
  if [ -z "$TXT_ACTIVE_FILE" ]; then
    _warn "no active txt playlist"; _info "start one with: m txt"; return
  fi
  _txt_read_lines "$TXT_ACTIVE_FILE"
  local total=${#TXT_LINES[@]}
  local current_query="${TXT_LINES[$(( TXT_ACTIVE_IDX + 1 ))]}"
  echo ""
  echo "  ${C}txt playlist:${X}  $(basename "$TXT_ACTIVE_FILE" .txt)"
  echo "  ${W}position:${X}    $(( TXT_ACTIVE_IDX + 1 )) / ${total}"
  echo "  ${W}current:${X}     ${current_query}"
  echo ""
  local ctx_start=$(( TXT_ACTIVE_IDX - 2 ))
  local ctx_end=$(( TXT_ACTIVE_IDX + 3 ))
  (( ctx_start < 0 )) && ctx_start=0
  (( ctx_end > total - 1 )) && ctx_end=$(( total - 1 ))
  local i=$ctx_start
  while [ $i -le $ctx_end ]; do
    local line="${TXT_LINES[$(( i + 1 ))]}"
    if [ $i -eq $TXT_ACTIVE_IDX ]; then
      printf "  ${G}â–¶ %d. %s${X}\n" "$(( i + 1 ))" "$line"
    else
      printf "    %d. %s\n" "$(( i + 1 ))" "$line"
    fi
    i=$(( i + 1 ))
  done
  echo ""
}

do_txts() {
  echo ""
  printf "  ${C}txt playlists  â†’  %s${X}\n" "$TXTS_DIR"
  echo ""
  local found=0
  _txt_state_read
  for f in "$TXTS_DIR"/*.txt(N); do
    local name; name=$(basename "$f" .txt)
    local count; count=$(grep -cvE '^\s*(#|$)' "$f" 2>/dev/null || echo 0)
    if [ "$f" = "$TXT_ACTIVE_FILE" ]; then
      printf "  ${G}â–¶${X} ${W}%s${X}  (%s songs)  ${C}â†’ m txt %s${X}\n" "$name" "$count" "$name"
    else
      printf "  âˆ™ ${W}%s${X}  (%s songs)  ${C}â†’ m txt %s${X}\n" "$name" "$count" "$name"
    fi
    found=1
  done
  if [ $found -eq 0 ]; then
    echo "  (none yet)"
    echo ""
    printf "  ${Y}How to add:${X} drop a .txt file into %s\n" "$TXTS_DIR"
    echo "  One song name per line. Lines starting with # are comments."
  fi
  echo ""
}

do_txtpick() {
  _need
  _txt_state_read
  [ -z "$TXT_ACTIVE_FILE" ] && { _err "no active txt playlist â€” start one with: m txt"; return 1; }
  _txt_read_lines "$TXT_ACTIVE_FILE"
  local total=${#TXT_LINES[@]}
  local display=()
  local i=0
  while [ $i -lt $total ]; do
    local marker="  "; [ $i -eq $TXT_ACTIVE_IDX ] && marker="â–¶ "
    display+=("${marker}$(( i + 1 )). ${TXT_LINES[$(( i + 1 ))]}")
    i=$(( i + 1 ))
  done
  local chosen
  chosen=$(printf '%s\n' "${display[@]}" | "$FZF" \
    --height 60% --reverse \
    --prompt "ðŸ“„ jump to > " \
    --header "â–¶ = current Â· ENTER to play Â· ESC cancel" \
    --no-sort)
  [ -z "$chosen" ] && { _warn "cancelled"; return; }
  local num; num=$(echo "$chosen" | grep -oE '[0-9]+\.' | head -1 | tr -d '.')
  [ -z "$num" ] && { _err "could not parse selection"; return 1; }
  local new_idx=$(( num - 1 ))
  local query="${TXT_LINES[$num]}"
  _info "searching: ${query}"
  local url; url=$(_txt_search_and_play_line "$query")
  [ -z "$url" ] && { _warn "could not find: $query"; return; }
  _txt_state_write "$TXT_ACTIVE_FILE" "$new_idx"
  _txt_kill_bg_job
  _silent '{"command":["playlist-clear"]}'
  _ipc_loadfile "$url" "replace"
  local title; title=$(_wait_prop media-title 20)
  local total_n; total_n=${#TXT_LINES[@]}
  _ok "â–¶  [${num}/${total_n}]  ${title:-$query}"
}

do_txtedit() {
  local arg="${1:-}"
  local f
  if [ -z "$arg" ]; then
    local files=("$TXTS_DIR"/*.txt(N))
    [ ${#files[@]} -eq 0 ] && { _err "no txt files in $TXTS_DIR"; return 1; }
    local picked
    picked=$(printf '%s\n' "${files[@]}" | xargs -I{} basename {} .txt | "$FZF" \
      --height 40% --reverse --prompt "âœ  edit > " --header "pick file to edit")
    [ -z "$picked" ] && { _warn "cancelled"; return; }
    f="$TXTS_DIR/${picked}.txt"
  else
    f=$(_txt_resolve "$arg")
    if [ -z "$f" ]; then
      f="$TXTS_DIR/${arg}.txt"
      _info "creating new txt playlist: $arg"
      printf '# %s\n# one song name per line, blank lines and # lines are ignored\n\n' "$arg" > "$f"
    fi
  fi
  local editor="${EDITOR:-nano}"
  "$editor" "$f"
  local count; count=$(grep -cvE '^\s*(#|$)' "$f" 2>/dev/null || echo 0)
  _ok "saved: $(basename "$f")  (${count} songs)"
}

do_txt_export() {
  _txt_state_read
  [ -z "$TXT_ACTIVE_FILE" ] && { _err "no active txt playlist â€” start one with: m txt"; return 1; }
  local name; name=$(basename "$TXT_ACTIVE_FILE" .txt)
  local out="$PLAYLIST_DIR/${name}.m3u"
  _txt_read_lines "$TXT_ACTIVE_FILE"
  [ ${#TXT_LINES[@]} -eq 0 ] && { _err "txt file is empty"; return 1; }
  _info "resolving ${#TXT_LINES[@]} songs to URLs (this may take a while)..."
  local tmpf; tmpf=$(mktemp "$PLAYLIST_DIR/${name}.XXXXXX")
  local count=0 i=1
  while [ $i -le ${#TXT_LINES[@]} ]; do
    local url; url=$(_txt_search_and_play_line "${TXT_LINES[$i]}")
    if [ -n "$url" ]; then
      echo "$url" >> "$tmpf"
      count=$(( count + 1 ))
      printf '\r\e[2K  â†’ resolved %d/%d...' "$count" "${#TXT_LINES[@]}" >&2
    else
      _warn "skipped (not found): ${TXT_LINES[$i]}"
    fi
    i=$(( i + 1 ))
  done
  printf '\r\e[2K' >&2
  if [[ $count -eq 0 ]]; then rm -f "$tmpf"; _err "could not resolve any tracks"; return 1; fi
  mv "$tmpf" "$out"
  _ok "exported '${name}' txt â†’ m3u  (${count} tracks)  â†’  m load ${name}"
}

# â”€â”€ sleep timer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
_sleep_timer_cancel() {
  local timer_file="$DATA_DIR/sleep_timer_pid"
  if [[ -f "$timer_file" ]]; then
    local tpid; tpid=$(cat "$timer_file" 2>/dev/null)
    [[ -n "$tpid" ]] && kill "$tpid" 2>/dev/null
    rm -f "$timer_file"
  fi
}

do_sleep() {
  _need
  if [[ "${1:-}" == "cancel" || "${1:-}" == "off" ]]; then
    _sleep_timer_cancel; _ok "sleep timer cancelled"; return
  fi
  [[ -z "${1:-}" ]] && { _err "usage: m sleep <minutes> | cancel"; return 1; }
  [[ "${1:-}" =~ ^[0-9]+$ ]] || { _err "usage: m sleep <minutes>  (integer)"; return 1; }
  local mins="$1" secs=$(( $1 * 60 ))
  _sleep_timer_cancel
  local timer_file="$DATA_DIR/sleep_timer_pid"
  (
    sleep "$secs"
    echo '{"command":["set_property","pause",true]}' | "$SOCAT" - "$SOCKET" >/dev/null 2>&1
    sleep 2
    if [[ -f "$MPV_PID_FILE" ]]; then
      local pid; pid=$(cat "$MPV_PID_FILE" 2>/dev/null)
      [[ -n "$pid" ]] && kill "$pid" 2>/dev/null
    fi
    rm -f "$timer_file"
  ) &
  local tpid=$!
  echo $tpid > "$timer_file"
  disown $tpid
  _ok "â²  sleep timer set: ${mins} minute(s)  (m sleep cancel to abort)"
}

# â”€â”€ equalizer & normalisation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
_EQ_BASS="lavfi=[equalizer=f=80:t=h:w=200:g=6,equalizer=f=40:t=h:w=80:g=4]"
_EQ_TREBLE="lavfi=[equalizer=f=8000:t=h:w=4000:g=5,equalizer=f=16000:t=h:w=4000:g=3]"
_EQ_VOCAL="lavfi=[equalizer=f=300:t=h:w=200:g=-2,equalizer=f=3000:t=h:w=2000:g=4]"
_EQ_LOUD="lavfi=[equalizer=f=60:t=h:w=120:g=5,equalizer=f=12000:t=h:w=6000:g=4,equalizer=f=1000:t=h:w=1000:g=-1]"

_af_set() {
  local filter="$1"
  local json; json=$("$JQ" -cn --arg af "$filter" '{"command":["set_property","af",$af]}')
  _silent_retry "$json"
}

_af_get_raw() {
  local raw; raw=$(_cmd '{"command":["get_property","af"]}' 2>/dev/null)
  echo "$raw" | "$JQ" -r '.data // ""' 2>/dev/null
}

do_eq() {
  _need
  local preset="${1:-}"
  case "$preset" in
    flat|off|none)
      local current; current=$(_af_get_raw)
      local new_af
      if echo "$current" | grep -qF "loudnorm"; then
        new_af=$(echo "$current" | awk -v frag="equalizer" 'BEGIN{FS=OFS=","}{ result=""; for(i=1;i<=NF;i++){if(index($i,frag)==0) result=(result==""?$i:result","$i)} print result }')
        new_af=$(echo "$new_af" | sed 's/lavfi=\[,/lavfi=[/g; s/,\]/]/g; s/lavfi=\[\]//g')
        _af_set "${new_af:-}"
      else
        _af_set ""
      fi
      _ok "ðŸŽš  equalizer: flat (off)"
      ;;
    bass)   _af_set "$_EQ_BASS";   _ok "ðŸŽš  equalizer: bass boost" ;;
    treble) _af_set "$_EQ_TREBLE"; _ok "ðŸŽš  equalizer: treble boost" ;;
    vocal)  _af_set "$_EQ_VOCAL";  _ok "ðŸŽš  equalizer: vocal" ;;
    loud|loudness) _af_set "$_EQ_LOUD"; _ok "ðŸŽš  equalizer: loudness" ;;
    '')
      local cur; cur=$(_af_get_raw)
      _info "current af filter: ${cur:-flat/off}"
      echo ""
      echo "  presets: flat  bass  treble  vocal  loud"
      echo "  usage:   m eq <preset>"
      echo ""
      ;;
    *)
      _err "unknown preset: $preset  (flat | bass | treble | vocal | loud)"
      return 1
      ;;
  esac
}

do_norm() {
  _need
  local current; current=$(_af_get_raw)
  if echo "$current" | grep -qF "loudnorm"; then
    local new_af; new_af=$(echo "$current" | awk 'BEGIN{FS=OFS=","}{result=""; for(i=1;i<=NF;i++){if(index($i,"acompressor")==0 && index($i,"loudnorm")==0) result=(result==""?$i:result","$i)} print result }')
    _af_set "${new_af:-}"
    _ok "ðŸ”‡ loudness normalisation: OFF"
  else
    local new_af="${current:+${current},}acompressor,loudnorm"
    _af_set "$new_af"
    _ok "ðŸ”Š loudness normalisation: ON  (levels balanced across tracks)"
  fi
}

# â”€â”€ v5-G â€” do_similar: python3 replaced with jq @uri â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
do_similar() {
  _need
  [ -s "$HISTORY_FILE" ] || { _warn "no history yet â€” play some tracks first"; return; }
  local seeds; seeds=$(_tac "$HISTORY_FILE" | awk -F'\t' '!seen[$2]++ {print $2}' | head -3)
  [ -z "$seeds" ] && { _warn "not enough history"; return; }
  local seed_title; seed_title=$(echo "$seeds" | head -1)

  if [[ -n "${LASTFM_API_KEY:-}" ]] && command -v curl >/dev/null 2>&1; then
    _info "querying Last.fm for tracks similar to: ${seed_title}"
    local artist track
    if echo "$seed_title" | grep -q ' - '; then
      artist=$(echo "$seed_title" | cut -d'-' -f1 | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
      track=$(echo "$seed_title"  | cut -d'-' -f2- | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
    else
      artist=""; track="$seed_title"
    fi

    # v5-G: use jq @uri instead of python3
    local enc_artist; enc_artist=$(printf '%s' "$artist" | "$JQ" -Rr '@uri' 2>/dev/null)
    local enc_track; enc_track=$(printf '%s' "$track" | "$JQ" -Rr '@uri' 2>/dev/null)

    local lastfm_resp
    lastfm_resp=$(curl -s --max-time 8 \
      "https://ws.audioscrobbler.com/2.0/?method=track.getsimilar&artist=${enc_artist}&track=${enc_track}&api_key=${LASTFM_API_KEY}&format=json&limit=10" \
      2>/dev/null)

    local similar_title
    similar_title=$(echo "$lastfm_resp" | "$JQ" -r \
      '.similartracks.track[] | "\(.artist.name) - \(.name)"' 2>/dev/null \
      | grep -v "^null" | head -5 \
      | awk 'BEGIN{srand()} {a[NR]=$0} END{if(NR>0) print a[int(rand()*NR)+1]}')

    if [[ -n "$similar_title" ]]; then
      _info "Last.fm recommends: ${similar_title}"
      local url; url=$(_pick "$similar_title") || return 1
      [ -z "$url" ] && { _warn "cancelled"; return; }
      _ipc_loadfile "$url" "append-play"
      _ok "âž• added Last.fm similar track: ${similar_title}"
      _queue_snapshot
      return
    fi
    _warn "Last.fm returned no similar tracks â€” falling back to YouTube search"
  fi

  _info "YouTube keyword search for: ${seed_title}  (set LASTFM_API_KEY for real recommendations)"
  local url; url=$(_pick "$seed_title") || return 1
  [ -z "$url" ] && { _warn "cancelled"; return; }
  _ipc_loadfile "$url" "append-play"
  _ok "âž• added to queue (YouTube keyword match â€” not semantic similarity)"
  _queue_snapshot
}

# â”€â”€ v5-H â€” do_export: CSV injection guard â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
do_export() {
  local target="${1:-likes}"
  local file
  case "$target" in
    likes)   file="$LIKES_FILE" ;;
    history) file="$HISTORY_FILE" ;;
    *) _err "usage: m export [likes|history]"; return 1 ;;
  esac
  [ -s "$file" ] || { _warn "no data to export in: $target"; return; }
  echo "date,title,url"
  awk -F'\t' '{
    # Escape double-quotes
    gsub(/"/, "\"\"", $1); gsub(/"/, "\"\"", $2); gsub(/"/, "\"\"", $3)
    # v5-H: CSV injection guard â€” prefix dangerous leading chars with tab
    if ($2 ~ /^[=+\-@]/) $2 = "\t" $2
    if ($3 ~ /^[=+\-@]/) $3 = "\t" $3
    printf "\"%s\",\"%s\",\"%s\"\n", $1, $2, $3
  }' "$file"
}

# â”€â”€ v5-X â€” m index: scan local music library â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
do_index() {
  if [[ -z "$FFPROBE" || ! -x "$FFPROBE" ]]; then
    _warn "ffprobe not found â€” install ffmpeg for local library indexing"
    _info "macOS: brew install ffmpeg | Linux: apt install ffmpeg"
    return 1
  fi
  [[ -d "$LOCAL_MUSIC_DIR" ]] || { _err "LOCAL_MUSIC_DIR not found: $LOCAL_MUSIC_DIR"; return 1; }

  _info "indexing $LOCAL_MUSIC_DIR ..."
  local tmpf; tmpf=$(mktemp "$DATA_DIR/index.XXXXXX")
  local count=0

  # Find all audio files
  find "$LOCAL_MUSIC_DIR" -type f \( \
    -iname "*.mp3" -o -iname "*.flac" -o -iname "*.m4a" -o \
    -iname "*.ogg" -o -iname "*.opus" -o -iname "*.wav" -o \
    -iname "*.aac" -o -iname "*.wma" \
  \) | while IFS= read -r f; do
    local title artist album duration
    title=$("$FFPROBE" -v quiet -print_format json -show_entries \
      format_tags=title,artist,album format=duration \
      "$f" 2>/dev/null | "$JQ" -r '
        (.format.tags.title // (.format.tags.TITLE // "")) as $t |
        (.format.tags.artist // (.format.tags.ARTIST // "")) as $a |
        (.format.tags.album // (.format.tags.ALBUM // "")) as $al |
        (.format.duration // "0") as $d |
        "\($t)\t\($a)\t\($al)\t\($d)"
      ' 2>/dev/null) || true

    # Fallback to filename
    if [[ -z "$title" || "$title" == $'\t\t\t'* ]]; then
      title="$(basename "$f" | sed 's/\.[^.]*$//')"$'\t''Unknown'$'\t''Unknown'$'\t0'
    fi

    printf '%s\t%s\n' "$f" "$title" >> "$tmpf"
    count=$(( count + 1 ))
    (( count % 50 == 0 )) && printf '\r\e[2K  â†’ indexed %d files...' "$count" >&2
  done

  printf '\r\e[2K' >&2
  mv "$tmpf" "$LOCAL_INDEX"
  count=$(wc -l < "$LOCAL_INDEX" | tr -d ' ')
  _ok "indexed ${count} tracks â†’ $LOCAL_INDEX"
  _info "use: m local \"song name\" to search your library"
}

do_local() {
  [[ -f "$LOCAL_INDEX" ]] || { _err "no local index â€” run: m index first"; return 1; }
  local query="${1:-}"

  local results
  if [[ -n "$query" ]]; then
    results=$(grep -i "$query" "$LOCAL_INDEX" 2>/dev/null | head -50)
  else
    results=$(cat "$LOCAL_INDEX")
  fi

  [[ -z "$results" ]] && { _warn "no local tracks matching: $query"; return; }

  local chosen
  chosen=$(echo "$results" | "$FZF" \
    --height 60% --reverse \
    --prompt "ðŸŽµ local > " \
    --header "ENTER play Â· ESC cancel" \
    --with-nth=2 --delimiter=$'\t' \
    --preview 'echo {} | awk -F"\t" "{print \"File:\", \$1, \"\nTitle:\", \$2, \"\nArtist:\", \$3}"' \
    --preview-window=down:3:wrap)

  [[ -z "$chosen" ]] && { _warn "cancelled"; return; }
  local filepath; filepath=$(printf '%s' "$chosen" | awk -F'\t' '{print $1}')
  [[ -f "$filepath" ]] || { _err "file not found: $filepath"; return 1; }

  _start
  _silent '{"command":["playlist-clear"]}'
  _ipc_loadfile "$filepath" "replace"
  local title; title=$(_wait_prop media-title 15)
  _ok "â–¶  ${title:-$(basename "$filepath")}"
}

# â”€â”€ v5-V â€” m reload-config: hot-reload without killing daemon â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
do_reload_config() {
  [ -f "$CONFIG_FILE" ] || { _warn "no config file at: $CONFIG_FILE"; return; }
  source "$CONFIG_FILE"
  _validate_config
  _ok "config reloaded from: $CONFIG_FILE"
  _info "note: daemon audio settings (device, volume) require m stop && m start to apply"
}

# â”€â”€ cast (stub with documentation) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
do_cast() {
  _info "casting via mpv --ao:"
  echo ""
  if [[ "$OS" == "mac" ]]; then
    echo "  macOS: use 'coreaudio' or AirPlay via system audio routing"
    echo "  List devices: m devices"
  else
    echo "  Linux: use PulseAudio/PipeWire sink routing"
    echo "  Set device: m devices  then  m sp / m hp"
  fi
  echo ""
  echo "  For Chromecast: install castnow (npm) or use mkchromecast"
  echo "  Example: yt-dlp -g \"\$(m now | grep URL)\" | castnow --toStdin"
  echo ""
}

# â”€â”€ m doctor â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
do_doctor() {
  echo ""
  echo "  ${C}m doctor â€” system diagnostics (v5)${X}"
  echo "  $(date)"
  echo ""
  echo "  ${W}Dependencies:${X}"
  for bin_var in YTDLP MPV FZF SOCAT JQ CURL CHAFA FFPROBE; do
    local bin_path="${(P)bin_var}"
    if [[ -n "$bin_path" && -x "$bin_path" ]]; then
      local ver=""
      case "$bin_var" in
        YTDLP)   ver=$("$bin_path" --version 2>/dev/null | head -1) ;;
        MPV)     ver=$("$bin_path" --version 2>/dev/null | head -1 | awk '{print $1,$2,$3}') ;;
        FZF)     ver=$("$bin_path" --version 2>/dev/null | head -1) ;;
        SOCAT)   ver=$("$bin_path" -V 2>&1 | head -1 | awk '{print $1,$2}') ;;
        JQ)      ver=$("$bin_path" --version 2>/dev/null | head -1) ;;
        CURL)    ver=$("$bin_path" --version 2>/dev/null | head -1) ;;
        CHAFA)   ver=$("$bin_path" --version 2>/dev/null | head -1) ;;
        FFPROBE) ver=$("$bin_path" -version 2>/dev/null | head -1) ;;
      esac
      printf "  ${G}âœ”${X}  %-8s  %s\n" "$bin_var" "${ver:-unknown version}"
    else
      local optional=""
      [[ "$bin_var" == "CURL" || "$bin_var" == "CHAFA" || "$bin_var" == "FFPROBE" ]] && optional=" (optional)"
      printf "  ${Y}â€“${X}  %-8s  ${Y}not found${X}%s\n" "$bin_var" "$optional"
    fi
  done
  echo ""

  # API keys status
  echo "  ${W}API Keys:${X}"
  printf "  YOUTUBE_API_KEY:   %s\n" "${YOUTUBE_API_KEY:+âœ” set (fast API search enabled)}"
  printf "  INVIDIOUS_HOST:    %s\n" "${INVIDIOUS_HOST:+âœ” set (Invidious search enabled)}"
  printf "  LASTFM_API_KEY:    %s\n" "${LASTFM_API_KEY:+âœ” set (real similar tracks enabled)}"
  printf "  SCROBBLE_URL:      %s\n" "${SCROBBLE_URL:+âœ” set}"
  [[ -z "$YOUTUBE_API_KEY$INVIDIOUS_HOST" ]] && \
    printf "  ${Y}â†’ tip: set YOUTUBE_API_KEY or INVIDIOUS_HOST in config for instant search${X}\n"
  echo ""

  echo "  ${W}Daemon:${X}"
  if [ ! -S "$SOCKET" ]; then
    printf "  ${R}âœ–${X}  socket: not present  (%s)\n" "$SOCKET"
  else
    printf "  ${G}âœ”${X}  socket: exists  (%s)\n" "$SOCKET"
    if echo '{"command":["get_version"]}' \
        | "$SOCAT" -t 2 - "$SOCKET" >/dev/null 2>&1; then
      printf "  ${G}âœ”${X}  IPC: responsive\n"
      local title; title=$(_get media-title 2>/dev/null)
      if [[ -n "$title" ]]; then
        local paused; paused=$(_get pause 2>/dev/null)
        local vol; vol=$(_get volume 2>/dev/null | awk '{printf "%.0f",$1}')
        printf "  ${G}âœ”${X}  now playing: %s  (paused=%s  vol=%s%%)\n" "$title" "$paused" "$vol"
      else
        printf "  ${C}â†’${X}  idle (no track loaded)\n"
      fi
    else
      printf "  ${R}âœ–${X}  IPC: unresponsive â€” run: m stop && m start\n"
    fi
  fi
  echo ""

  echo "  ${W}Lock files:${X}"
  if [ -d "$LOCK_FILE_D" ]; then
    local lock_pid; lock_pid=$(cat "$LOCK_FILE" 2>/dev/null || echo "")
    if [[ -n "$lock_pid" ]] && kill -0 "$lock_pid" 2>/dev/null; then
      printf "  ${Y}âš ${X}  start.lock held by PID %s (live)\n" "$lock_pid"
    else
      printf "  ${R}âœ–${X}  start.lock STALE (PID %s dead) â€” run: m stop\n" "${lock_pid:-unknown}"
    fi
  else
    printf "  ${G}âœ”${X}  no stale locks\n"
  fi
  echo ""

  echo "  ${W}Data files:${X}"
  local history_lines=0 likes_lines=0 bm_lines=0
  [ -f "$HISTORY_FILE" ] && history_lines=$(wc -l < "$HISTORY_FILE" | tr -d ' ')
  [ -f "$LIKES_FILE"   ] && likes_lines=$(wc -l < "$LIKES_FILE"   | tr -d ' ')
  [ -f "$BOOKMARKS_FILE" ] && bm_lines=$(wc -l < "$BOOKMARKS_FILE" | tr -d ' ')
  printf "  history:   %s entries\n" "$history_lines"
  printf "  likes:     %s entries\n" "$likes_lines"
  printf "  bookmarks: %s entries\n" "$bm_lines"
  if [ -f "$LOCAL_INDEX" ]; then
    printf "  local lib: %s tracks indexed\n" "$(wc -l < "$LOCAL_INDEX" | tr -d ' ')"
  fi
  echo ""

  echo "  ${W}Cache:${X}"
  local cache_total=0 cache_expired=0
  for f in "$CACHE_DIR"/*.cache(N); do
    cache_total=$(( cache_total + 1 ))
    [ "$(_cache_age "$f")" -ge "$CACHE_TTL" ] && cache_expired=$(( cache_expired + 1 ))
  done
  printf "  %s total  |  %s fresh  |  %s expired  |  TTL: %ss\n" \
    "$cache_total" "$(( cache_total - cache_expired ))" "$cache_expired" "$CACHE_TTL"
  echo ""
}

do_update() {
  _info "updating yt-dlp..."
  local old_ver; old_ver=$("$YTDLP" --version 2>/dev/null | head -1)
  local rc=0
  if [[ "$OS" == "mac" ]]; then
    if command -v brew >/dev/null 2>&1; then brew upgrade yt-dlp 2>&1 || rc=$?
    else "$YTDLP" -U 2>&1 || rc=$?; fi
  else
    if command -v pip3 >/dev/null 2>&1; then pip3 install -U yt-dlp 2>&1 || rc=$?
    elif command -v pip >/dev/null 2>&1; then pip install -U yt-dlp 2>&1 || rc=$?
    else "$YTDLP" -U 2>&1 || rc=$?; fi
  fi
  [[ $rc -ne 0 ]] && _warn "update may have failed (exit $rc)"
  local new_ver; new_ver=$("$YTDLP" --version 2>/dev/null | head -1)
  if [[ "$old_ver" != "$new_ver" ]]; then _ok "yt-dlp updated: ${old_ver} â†’ ${new_ver}"
  else _ok "yt-dlp already up-to-date: ${new_ver}"; fi
  rm -f "$CACHE_DIR/.ytdlp_version_check"
}

do_log() {
  if [[ ! -s "$MPV_LOG" ]]; then _info "mpv log is empty: $MPV_LOG"; return; fi
  echo ""; echo "  ${C}mpv log:${X}  $MPV_LOG"; echo ""
  tail -50 "$MPV_LOG"; echo ""
}

do_log_clear() { > "$MPV_LOG"; _ok "mpv log cleared"; }

do_cache_clear() {
  local count; count=$(ls "$CACHE_DIR"/*.cache 2>/dev/null | wc -l | tr -d ' ')
  rm -f "$CACHE_DIR"/*.cache
  _ok "cleared ${count} cached search(es)"
}

do_cache_stats() {
  local total=0 expired=0 fresh=0
  for f in "$CACHE_DIR"/*.cache(N); do
    total=$(( total + 1 ))
    if [ "$(_cache_age "$f")" -ge "$CACHE_TTL" ]; then expired=$(( expired + 1 ))
    else fresh=$(( fresh + 1 )); fi
  done
  echo ""; echo "  ${C}cache stats:${X}"
  echo "  total:   ${total}"; echo "  fresh:   ${G}${fresh}${X}  (TTL: ${CACHE_TTL}s)"
  echo "  expired: ${Y}${expired}${X}"; echo "  dir:     $CACHE_DIR"; echo ""
}

do_cache_prune() {
  local count=0
  for f in "$CACHE_DIR"/*.cache(N); do
    if [ "$(_cache_age "$f")" -ge "$CACHE_TTL" ]; then rm -f "$f"; count=$(( count + 1 )); fi
  done
  _ok "pruned ${count} expired cache entrie(s)"
}

do_devices() {
  echo ""; echo "  ${C}audio devices:${X}"
  "$MPV" --audio-device=help 2>&1 | grep "'" | sed 's/^/  /'
  echo ""
  echo "  current:     ${W}$(_get audio-device)${X}"
  echo "  speakers:    ${W}${AUDIO_DEVICE_SPEAKERS:-not configured}${X}"
  echo "  headphones:  ${W}${AUDIO_DEVICE_HEADPHONES:-not configured}${X}"
  echo "  (set in: $CONFIG_FILE)"; echo ""
}

# â”€â”€ Plugin system (v5) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
_load_plugins() {
  [[ -d "$PLUGINS_DIR" ]] || return
  for plugin in "$PLUGINS_DIR"/*.zsh(N); do
    source "$plugin" 2>/dev/null && _info "plugin loaded: $(basename "$plugin")" || \
      _warn "plugin error: $(basename "$plugin")"
  done
}
_load_plugins

# â”€â”€ help â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
do_help() {
  cat <<EOF

  ${C}m â€” terminal music CLI${X}   (v5 "God Tier")
  data: ~/music_system/   config: $CONFIG_FILE
  log:  $MPV_LOG

  ${W}SPEED UP SEARCH${X}
    Set in $CONFIG_FILE:
      YOUTUBE_API_KEY=...   â†’ instant search via YouTube Data API (milliseconds)
      INVIDIOUS_HOST=...    â†’ privacy-friendly Invidious API (fast, no key needed)
      (default: yt-dlp scrape, 2â€“5s)

  ${W}PLAY${X}
    m "query"              search YouTube & play (fzf picker)
    m ~/path/to/file.mp3   play a local file directly
    m "query" -a           add to queue (dedup-guarded)
    m "query" -a -f        force-add (bypass dedup)
    m "query" -an          add as next track (play after current)
    m "query" -hp          play via headphones
    m "query" -sp          play via speakers

  ${W}TRANSPORT${X}
    pause / pp             toggle pause
    next  / mn             next track
    prev  / mb             previous track
    seek +30               seek forward 30s (shows mini progress bar)
    seek -15               seek back 15s
    seek 1:30              jump to 1m30s
    seek 90                jump to 90s
    speed 1.5              set playback speed (0.25â€“4.0)
    speed + / - / r        step speed / reset to 1x
    stop                   kill daemon
    start                  start daemon

  ${W}VOLUME & OUTPUT${X}
    vol / vol 80 / vol + / vol -   show/set/step volume (0-150)
    hp / headphones        switch to headphones
    sp / speakers          switch to speakers
    devices                list audio devices

  ${W}AUDIO FILTERS${X}
    eq [flat|bass|treble|vocal|loud]   equalizer preset
    norm                   toggle loudness normalisation

  ${W}INFO & UI${X}
    now                    current track + position
    bar / progress         live progress bar (p/n/b/seek/vol/r/l=lyrics/q)
    lyrics                 real-time synced lyrics (lrclib.net, no key needed)
    art                    terminal album art (requires chafa)
    ui                     unified TUI dashboard (requires tmux)
    scrub / slider         interactive seek slider
    queue                  show queue
    status                 daemon status + all state

  ${W}QUEUE MANAGEMENT${X}
    shuffle                shuffle queue
    repeat / rp            toggle repeat-playlist
    repeat-one / ro        toggle repeat-one
    clear                  clear queue
    qmove <from> <to>      move track (1-based)
    qrm <pos>              remove track (1-based)
    queue-restore / qr     restore queue from auto-snapshot

  ${W}BOOKMARKS (v5)${X}
    bookmark [name]        save current track+position as named bookmark
    bookmarks              list all bookmarks
    bookmark-load / bl     fzf-pick and restore a bookmark

  ${W}AUTO-DJ (v5)${X}
    autodj                 toggle Auto-DJ (auto-refills queue from Last.fm)
                           set LASTFM_API_KEY for real recommendations

  ${W}LIKES${X}
    like / unlike / likes  like current track / remove / list
    likes-play / lp        fzf-pick & play a liked track
    love                   play random liked track (reservoir sampling)

  ${W}HISTORY${X}
    history                fuzzy-search & replay history (dedup on last 50)
    history-clear          wipe history
    similar                add similar track (Last.fm or YouTube)

  ${W}TXT PLAYLISTS${X}
    txts                   list all txt playlists
    txt [name] [--resume]  load txt playlist (v5: parallel resolution, resume)
    txtnext / tn           next song in txt playlist
    txtprev / tp           previous song
    txtnow                 show active txt + context
    txtpick / tj           fzf-jump to any song in txt
    txtedit [name]         edit/create txt file in \$EDITOR
    txt-export             resolve active txt â†’ saved m3u

  ${W}QUEUE PLAYLISTS${X}
    save <n>               save current queue as playlist
    load <n>               load playlist (O(1) dedup)
    playlists / pls        list saved playlists
    pldel <n>              delete playlist

  ${W}LOCAL LIBRARY (v5)${X}
    index                  scan \$LOCAL_MUSIC_DIR with ffprobe, build index
    local [query]          fzf-search & play from local library

  ${W}DOWNLOAD & IMPORT${X}
    dl "query"             download as MP3 (progress visible)
    dl-list                list downloaded files
    import "url"           import YouTube playlist

  ${W}SLEEP TIMER${X}
    sleep <minutes> / sleep cancel   sleep timer

  ${W}EXPORT${X}
    export [likes|history]   print as CSV (CSV injection safe)

  ${W}CONFIG${X}
    reload-config          hot-reload config without restarting daemon

  ${W}UPDATES & DIAGNOSTICS${X}
    update                 update yt-dlp
    doctor                 full diagnostics: deps, API keys, IPC, locks, cache
    log / log-clear        mpv error log
    cache-clear/prune/stats  cache management

  ${W}SPONSORBLOCK${X}
    Drop the mpv-sponsorblock lua script into ~/.config/mpv/scripts/ to
    automatically skip non-music sections in YouTube videos.
    Get it: https://github.com/po5/mpv_sponsorblock

  ${W}PLUGINS${X}
    Drop .zsh files into: $PLUGINS_DIR
    They are sourced at startup. Define do_mycommand() functions.

EOF
}

# â”€â”€ main dispatch â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
_check_ytdlp_age

[ $# -eq 0 ] && { do_status; exit 0; }

case "$1" in
  pause|pp)            do_pause;                   exit 0 ;;
  next|mn)             do_next;                    exit 0 ;;
  prev|mb)             do_prev;                    exit 0 ;;
  stop)                do_stop;                    exit 0 ;;
  start)               do_start;                   exit 0 ;;
  shuffle)             do_shuffle;                 exit 0 ;;
  repeat|rp)           do_repeat;                  exit 0 ;;
  repeat-one|ro)       do_repeat_one;              exit 0 ;;
  clear)               do_clear;                   exit 0 ;;
  now)                 do_now;                     exit 0 ;;
  bar|progress)        do_bar;                     exit 0 ;;
  lyrics)              do_lyrics;                  exit 0 ;;
  art)                 do_art;                     exit 0 ;;
  ui)                  do_ui;                      exit 0 ;;
  scrub|slider)        do_scrub;                   exit 0 ;;
  queue)               do_queue;                   exit 0 ;;
  qmove)               do_queue_move "$2" "$3";    exit 0 ;;
  qrm)                 do_queue_remove "$2";       exit 0 ;;
  status)              do_status;                  exit 0 ;;
  hp|headphones)       do_hp;                      exit 0 ;;
  sp|speakers)         do_sp;                      exit 0 ;;
  devices)             do_devices;                 exit 0 ;;
  playlists|pls)       do_playlists;               exit 0 ;;
  save)                do_save "${2:-}";           exit 0 ;;
  load)                do_load "${2:-}";           exit 0 ;;
  pldel)               do_playlist_del "${2:-}";   exit 0 ;;
  import)              do_import "${2:-}";         exit 0 ;;
  dl)                  do_dl "${2:-}";             exit 0 ;;
  dl-list)             do_dl_list;                 exit 0 ;;
  txt)                 do_txt "${2:-}" "${3:-}";   exit 0 ;;
  txts)                do_txts;                    exit 0 ;;
  txtnext|tn)          do_txtnext;                 exit 0 ;;
  txtprev|tp)          do_txtprev;                 exit 0 ;;
  txtnow)              do_txtnow;                  exit 0 ;;
  txtpick|tj)          do_txtpick;                 exit 0 ;;
  txtedit|te)          do_txtedit "${2:-}";        exit 0 ;;
  txt-export)          do_txt_export;              exit 0 ;;
  vol|volume)          do_vol "${2:-}";            exit 0 ;;
  seek)                do_seek "${2:-}";           exit 0 ;;
  speed)               do_speed "${2:-}";          exit 0 ;;
  like)                do_like;                    exit 0 ;;
  unlike)              do_unlike;                  exit 0 ;;
  likes)               do_likes;                   exit 0 ;;
  likes-play|lp)       do_likes_play;              exit 0 ;;
  love)                do_love;                    exit 0 ;;
  similar)             do_similar;                 exit 0 ;;
  history|hist)        do_history;                 exit 0 ;;
  history-clear)       do_history_clear;           exit 0 ;;
  eq)                  do_eq "${2:-}";             exit 0 ;;
  norm)                do_norm;                    exit 0 ;;
  sleep)               do_sleep "${2:-}";          exit 0 ;;
  export)              do_export "${2:-}";         exit 0 ;;
  update)              do_update;                  exit 0 ;;
  doctor)              do_doctor;                  exit 0 ;;
  queue-restore|qr)    do_queue_restore;           exit 0 ;;
  log)                 do_log;                     exit 0 ;;
  log-clear)           do_log_clear;               exit 0 ;;
  cache-clear)         do_cache_clear;             exit 0 ;;
  cache-prune)         do_cache_prune;             exit 0 ;;
  cache-stats)         do_cache_stats;             exit 0 ;;
  autodj)              do_autodj;                  exit 0 ;;
  bookmark)            do_bookmark "${2:-}";       exit 0 ;;
  bookmarks)           do_bookmarks;               exit 0 ;;
  bookmark-load|bl)    do_bookmark_load;           exit 0 ;;
  index)               do_index;                   exit 0 ;;
  local)               do_local "${2:-}";          exit 0 ;;
  reload-config)       do_reload_config;           exit 0 ;;
  cast)                do_cast;                    exit 0 ;;
  help|-h|--help)      do_help;                    exit 0 ;;
esac

# â”€â”€ Free-form query with optional flags â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
typeset -a QUERY_ARGS
QUERY_ARGS=()
FLAG_ADD=0
FLAG_FORCE=0
FLAG_NEXT=0
FLAG_HP=0
FLAG_SP=0

for arg in "$@"; do
  case "$arg" in
    -a|--add)          FLAG_ADD=1 ;;
    -f|--force)        FLAG_FORCE=1 ;;
    -an|--add-next)    FLAG_ADD=1; FLAG_NEXT=1 ;;
    -hp|--headphones)  FLAG_HP=1 ;;
    -sp|--speakers)    FLAG_SP=1 ;;
    -*)                _die "unknown flag: $arg  (run: m help)" ;;
    *)                 QUERY_ARGS+=("$arg") ;;
  esac
done

[ ${#QUERY_ARGS[@]} -eq 0 ] && _die "no query â€” usage: m \"song name\"  or  m help"

QUERY="${(j: :)QUERY_ARGS}"

if [ $FLAG_ADD -eq 1 ]; then
  if [ $FLAG_NEXT -eq 1 ]; then
    do_add_next "$QUERY"
  elif [ $FLAG_FORCE -eq 1 ]; then
    do_add_force "$QUERY"
  else
    do_add "$QUERY"
  fi
else
  do_play "$QUERY"
fi

[ $FLAG_HP -eq 1 ] && sleep 0.4 && do_hp
[ $FLAG_SP -eq 1 ] && sleep 0.4 && do_sp
