#!/usr/bin/env zsh
# ============================================================
#  m â€” terminal music CLI  (hardened build v4)
#  All state lives in ~/music_system/
#
#  Fixes applied (v3 â†’ v4):
#   v4-A  _need probes live IPC socket â€” stale socket now caught
#   v4-B  _lock steal guard: max 3 steal attempts, no infinite loop
#   v4-C  do_load O(nÂ²) dedup fixed â€” playlist fetched once pre-loop
#   v4-D  _txt_search_and_play_line respects $SEARCH_RESULTS (was hardcoded ytsearch5)
#   v4-E  bg txt job uses generation counter â€” eliminates PID-file race
#   v4-F  do_eq / do_norm use structured af array â€” sed surgery removed
#   v4-G  _wait_prop max bumped to 60; sleep formula fixed; smarter backoff
#   v4-H  _get_multi fallback checks per-property errors correctly
#   v4-I  do_play clears queue AFTER URL confirmed â€” ESC no longer destroys queue
#   v4-J  history trim uses tail -n (single pass) instead of double _tac
#   v4-K  do_stop removes LOCK_FILE_D sentinel â€” prevents permanent deadlock
#   v4-L  _scrobble disown'd â€” SIGHUP can no longer kill in-flight scrobbles
#   v4-M  m doctor command: full diagnostics, dep versions, IPC probe, stale lock check
#   v4-N  do_similar uses Last.fm API if LASTFM_API_KEY set; else honest fallback label
#   v4-O  Queue auto-snapshot on every track change; m queue-restore to reload
#   v4-P  do_dl: explicit --progress flag; yt-dlp progress shown correctly
#   v4-Q  _EQ_NONE removed (was unused dead code with wrong value)
#   v4-R  do_import guard against silent overwrite of existing playlist name
#   v4-S  _validate_config loop hardened against odd-count variable list under set -u
#   v4-T  Cache key includes $USER to prevent collisions on shared filesystems
#
#  Fixes carried forward (v2 â†’ v3):
#    #1  _err in subshells: _die() for fatal exits, _err() returns 1
#    #2  _log_history tmpf race: create tmpf only inside lock
#    #3  _start non-atomic lock: use mkdir-based lock for _start too
#    #4  do_stop kills bg txt job before destroying socket
#    #5  _pick validates result count before caching
#    #6  zsh 1-based arrays documented & enforced; no bash ambiguity
#    #7  _shuf1 modulo bias fixed with awk RNG
#    #8  do_seek rewritten with explicit case branches
#    #9  _bar_cleanup scoping: prefixed name avoids namespace pollution
#   #10  do_dl checks yt-dlp exit code
#   #11  IPC retry wrapper _silent_retry for critical commands
#   #12  _wait_prop shows spinner; exponential sleep
#   #13  txt bg job captures SOCAT/SOCKET/JQ at spawn time
#   #14  yt-dlp version freshness check + m update command
#   #15  do_history preview uses awk instead of word-splitting cut
#   #16  config validated after sourcing (numeric guards)
#   #17  do_bar batches IPC into single get_property_list call
#   #18  do_txts marker display fixed
#   #19  queue highlight comment clarified (architecture is correct)
#   #20  mpv stderr piped to $DATA_DIR/mpv.log
#   #21  _bootstrap always creates all dirs unconditionally
#   #22  m update command added
#   #23  Last.fm / ListenBrainz scrobble stub in _log_history
#   #24  m txt-export: promote active txt playlist to m3u
#   #25  m sleep <minutes>: sleep timer
#   #26  m eq: equalizer preset toggle
#   #27  m similar: play-similar from history seeds
#   #28  m norm: loudness normalisation toggle
#   #29  do_bar shows volume
#   #30  m cast stub (documents mpv --ao)
#   #31  do_add deduplication guard
#   #32  m export: likes/history â†’ CSV
#   #33  set -u for unset variable guard (pipefail omitted: subshells)
#   #34  _die vs _err semantics separated
#   #35  QUERY built as array, not string concat
#   #36  do_dl embeds thumbnail + metadata
#   #37  _unlock verifies PID before removing lockdir
#
#  Structure:
#    ~/music_system/
#    â”œâ”€â”€ m                  â† this script (symlinked to /usr/local/bin/m)
#    â”œâ”€â”€ config             â† optional overrides (sourced if present)
#    â”œâ”€â”€ socket/            â† mpv IPC socket + mpv.pid
#    â”œâ”€â”€ cache/             â† yt-dlp search caches (TTL configurable)
#    â”œâ”€â”€ playlists/         â† saved .m3u playlists
#    â”œâ”€â”€ txts/              â† .txt playlist files
#    â”œâ”€â”€ downloads/         â† m dl output
#    â”œâ”€â”€ data/
#    â”‚   â”œâ”€â”€ likes          â† liked tracks  (TSV: date\ttitle\turl)
#    â”‚   â”œâ”€â”€ history        â† play history  (TSV: date\ttitle\turl)
#    â”‚   â”œâ”€â”€ txt_state      â† active txt playlist state
#    â”‚   â”œâ”€â”€ txt_bg_gen     â† bg job generation counter (v4-E)
#    â”‚   â”œâ”€â”€ queue_snapshot.m3u  â† auto-saved queue snapshot (v4-O)
#    â”‚   â””â”€â”€ mpv.log        â† mpv stderr log
#    â””â”€â”€ locks/             â† lockfiles
# ============================================================

# FIX #33 â€” guard against unset variable use
# Note: set -e is NOT used because we handle errors explicitly;
# set -e in interactive-style CLIs causes too many false exits.
set -u

# â”€â”€ paths â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
MUSIC_ROOT="${MUSIC_ROOT:-$HOME/music_system}"
SOCKET_DIR="$MUSIC_ROOT/socket"
SOCKET="$SOCKET_DIR/mpv.sock"
MPV_PID_FILE="$SOCKET_DIR/mpv.pid"
CACHE_DIR="$MUSIC_ROOT/cache"
PLAYLIST_DIR="$MUSIC_ROOT/playlists"
TXTS_DIR="$MUSIC_ROOT/txts"
DOWNLOADS_DIR="$MUSIC_ROOT/downloads"
DATA_DIR="$MUSIC_ROOT/data"
LOCK_DIR="$MUSIC_ROOT/locks"
LOCK_FILE="$LOCK_DIR/start.lock"
LOCK_FILE_D="$LOCK_FILE.d"   # atomic mkdir sentinel for _start
HISTORY_LOCK="$LOCK_DIR/history.lock"
LIKES_FILE="$DATA_DIR/likes"
HISTORY_FILE="$DATA_DIR/history"
TXT_STATE_FILE="$DATA_DIR/txt_state"
TXT_BG_GEN_FILE="$DATA_DIR/txt_bg_gen"   # v4-E: generation counter for bg txt job
QUEUE_SNAPSHOT="$DATA_DIR/queue_snapshot.m3u"  # v4-O: auto-saved queue
MPV_LOG="$DATA_DIR/mpv.log"   # FIX #20
CONFIG_FILE="$MUSIC_ROOT/config"

# â”€â”€ defaults (overridable via config file) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CACHE_TTL=3600          # seconds
HISTORY_MAX=500         # lines
DEFAULT_VOLUME=80       # 0â€“150
VOLUME_STEP=5
SEARCH_RESULTS=20       # fzf picker results
AUDIO_DEVICE_SPEAKERS=""
AUDIO_DEVICE_HEADPHONES=""
SCROBBLE_URL=""         # optional: ListenBrainz / webhook endpoint
YTDLP_MAX_AGE_DAYS=30  # warn if yt-dlp binary is older than this
LASTFM_API_KEY=""       # optional: Last.fm API key for m similar (v4-N)

# â”€â”€ load user config â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# shellcheck disable=SC1090
[ -f "$CONFIG_FILE" ] && source "$CONFIG_FILE"

# v4-S â€” _validate_config rewritten to be safe under set -u
# The original 'for var val min max in ...' loop is not robust if the list
# has an odd count â€” it leaves 'max' unset which trips set -u.
# Use an explicit array of tuples instead.
_validate_config() {
  local -a _cfg_checks
  _cfg_checks=(
    "CACHE_TTL:${CACHE_TTL}:1:86400"
    "HISTORY_MAX:${HISTORY_MAX}:10:100000"
    "DEFAULT_VOLUME:${DEFAULT_VOLUME}:0:150"
    "VOLUME_STEP:${VOLUME_STEP}:1:50"
    "SEARCH_RESULTS:${SEARCH_RESULTS}:1:50"
    "YTDLP_MAX_AGE_DAYS:${YTDLP_MAX_AGE_DAYS}:1:365"
  )
  local entry var val min max
  for entry in "${_cfg_checks[@]}"; do
    var="${entry%%:*}"; local _rest="${entry#*:}"
    val="${_rest%%:*}"; _rest="${_rest#*:}"
    min="${_rest%%:*}"; max="${_rest#*:}"
    if [[ ! "$val" =~ ^[0-9]+$ ]] || (( val < min || val > max )); then
      echo "${Y}âš  config: ${var}=${val} is invalid (expected integer ${min}â€“${max}), using default${X}" >&2
    fi
  done
  # Reset to safe defaults if anything was bad
  [[ "$CACHE_TTL"      =~ ^[0-9]+$ ]] || CACHE_TTL=3600
  [[ "$HISTORY_MAX"    =~ ^[0-9]+$ ]] || HISTORY_MAX=500
  [[ "$DEFAULT_VOLUME" =~ ^[0-9]+$ ]] || DEFAULT_VOLUME=80
  [[ "$VOLUME_STEP"    =~ ^[0-9]+$ ]] || VOLUME_STEP=5
  [[ "$SEARCH_RESULTS" =~ ^[0-9]+$ ]] || SEARCH_RESULTS=20
  (( DEFAULT_VOLUME > 150 )) && DEFAULT_VOLUME=150
  (( VOLUME_STEP > 50 ))    && VOLUME_STEP=5
}
_validate_config

# â”€â”€ colours â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
R=$'\e[0;31m'; G=$'\e[0;32m'; Y=$'\e[0;33m'
C=$'\e[0;36m'; W=$'\e[1;37m'; M=$'\e[0;35m'; X=$'\e[0m'

# â”€â”€ OS detection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
_os() {
  case "$(uname -s)" in
    Darwin) echo "mac" ;;
    Linux)  echo "linux" ;;
    *)      echo "unknown" ;;
  esac
}
OS=$(_os)

# â”€â”€ cross-platform helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

_md5() {
  if [[ "$OS" == "mac" ]]; then
    md5
  else
    md5sum | cut -c1-32
  fi
}

_mtime() {
  local f="$1"
  if [[ "$OS" == "mac" ]]; then
    stat -f%m "$f" 2>/dev/null || echo 0
  else
    stat -c%Y "$f" 2>/dev/null || echo 0
  fi
}

_tac() {
  if command -v tac &>/dev/null; then
    tac "$@"
  else
    tail -r "$@"
  fi
}

# FIX #7 â€” _shuf1: unbiased random line using awk RNG (no modulo bias)
_shuf1() {
  local f="$1"
  [[ -s "$f" ]] || return 1
  awk 'BEGIN{srand()} {a[NR]=$0} END{ if(NR>0) print a[int(rand()*NR)+1] }' "$f"
}

# v4-B â€” atomic mkdir-based lock; stale-lock steal capped at 3 attempts
# _lock <lockfile_base> [timeout_seconds]
# Uses mkdir of <lockfile_base>.d as the atomic sentinel.
# Stale lock steal is limited to MAX_STEALS=3 to prevent infinite loop
# if the locking process keeps dying and respawning rapidly.
_lock() {
  local lf="$1" timeout="${2:-5}"
  local deadline=$(( $(date +%s) + timeout ))
  local steal_count=0
  local MAX_STEALS=3
  while ! mkdir "${lf}.d" 2>/dev/null; do
    if [[ $(date +%s) -gt $deadline ]]; then
      # Stale lock check: if PID in lockfile is dead, steal the lock (bounded)
      if [[ $steal_count -lt $MAX_STEALS && -f "$lf" ]]; then
        local dead_pid; dead_pid=$(cat "$lf" 2>/dev/null)
        if [[ -n "$dead_pid" ]] && ! kill -0 "$dead_pid" 2>/dev/null; then
          steal_count=$(( steal_count + 1 ))
          rmdir "${lf}.d" 2>/dev/null
          rm -f "$lf"
          # Reset deadline for one more full timeout window after each steal
          deadline=$(( $(date +%s) + timeout ))
          continue  # retry mkdir with fresh deadline
        fi
      fi
      return 1  # lock held by live process or max steals exceeded
    fi
    sleep 0.05
  done
  echo $$ > "$lf"
  return 0
}

# FIX #37 â€” _unlock verifies our PID before removing
_unlock() {
  local lf="$1"
  local stored_pid; stored_pid=$(cat "$lf" 2>/dev/null)
  if [[ "$stored_pid" == "$$" ]]; then
    rm -f "$lf"
    rmdir "${lf}.d" 2>/dev/null
  fi
}

# â”€â”€ binary resolution â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
_resolve_bin() {
  local name="$1"
  local found; found=$(command -v "$name" 2>/dev/null)
  [ -n "$found" ] && { echo "$found"; return 0; }
  for prefix in /opt/homebrew/bin /usr/local/bin /home/linuxbrew/.linuxbrew/bin; do
    [ -x "$prefix/$name" ] && { echo "$prefix/$name"; return 0; }
  done
  echo ""
  return 1
}

YTDLP="${YTDLP:-$(_resolve_bin yt-dlp)}"
MPV="${MPV:-$(_resolve_bin mpv)}"
FZF="${FZF:-$(_resolve_bin fzf)}"
SOCAT="${SOCAT:-$(_resolve_bin socat)}"
JQ="${JQ:-$(_resolve_bin jq)}"

# â”€â”€ bootstrap dirs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# FIX #21 â€” always create all dirs unconditionally (idempotent)
_bootstrap() {
  mkdir -p "$SOCKET_DIR" "$CACHE_DIR" "$PLAYLIST_DIR" \
           "$TXTS_DIR" "$DOWNLOADS_DIR" "$DATA_DIR" "$LOCK_DIR"
  [[ ! -f "$LIKES_FILE" ]]   && touch "$LIKES_FILE"
  [[ ! -f "$HISTORY_FILE" ]] && touch "$HISTORY_FILE"
  if [[ ! -f "$CONFIG_FILE" ]]; then
    cat > "$CONFIG_FILE" <<'EOF'
# m â€” user config  (uncomment + edit to override defaults)
# CACHE_TTL=3600
# HISTORY_MAX=500
# DEFAULT_VOLUME=80
# VOLUME_STEP=5
# SEARCH_RESULTS=20
# YTDLP_MAX_AGE_DAYS=30
# YTDLP=/usr/local/bin/yt-dlp
# MPV=/usr/local/bin/mpv
# AUDIO_DEVICE_SPEAKERS=coreaudio/BuiltInSpeakerDevice
# AUDIO_DEVICE_HEADPHONES=coreaudio/BuiltInHeadphoneOutputDevice
# SCROBBLE_URL=https://api.listenbrainz.org/1/submit-listens
# LASTFM_API_KEY=your_key_here   # enables real similar-track recommendations
EOF
  fi
}
_bootstrap

# â”€â”€ logging helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# FIX #1 + #34 â€” separate _die (exits, for top-level fatal errors)
#                from _err (prints + returns 1, safe inside subshells)
_die()  { echo "${R}âœ– $*${X}" >&2; exit 1; }
_err()  { echo "${R}âœ– $*${X}" >&2; return 1; }
_ok()   { echo "${G}âœ” $*${X}"; }
_info() { echo "${C}â†’ $*${X}"; }
_warn() { echo "${Y}âš  $*${X}"; }

# â”€â”€ dependency check â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
_check_deps() {
  local missing=0
  for bin in "$YTDLP" "$MPV" "$FZF" "$SOCAT" "$JQ"; do
    if [[ -z "$bin" || ! -x "$bin" ]]; then
      _warn "missing binary: ${bin:-<unresolved>}"
      missing=1
    fi
  done
  if [[ $missing -eq 1 ]]; then
    _die "install missing deps:\n  macOS: brew install yt-dlp mpv fzf socat jq\n  Linux: sudo apt install mpv socat jq fzf && pip install yt-dlp"
  fi
}
_check_deps

# FIX #14 â€” yt-dlp version freshness check
_check_ytdlp_age() {
  local ver_file="$CACHE_DIR/.ytdlp_version_check"
  # Only re-check once per day
  local age; age=$(_cache_age "$ver_file" 2>/dev/null || echo 99999)
  (( age < 86400 )) && return
  touch "$ver_file"

  local ver_str; ver_str=$("$YTDLP" --version 2>/dev/null | head -1)
  # yt-dlp version format: YYYY.MM.DD[.N]
  local ver_date; ver_date=$(echo "$ver_str" | grep -oE '^[0-9]{4}\.[0-9]{2}\.[0-9]{2}')
  [[ -z "$ver_date" ]] && return

  local ver_epoch
  if [[ "$OS" == "mac" ]]; then
    ver_epoch=$(date -j -f "%Y.%m.%d" "$ver_date" "+%s" 2>/dev/null || echo 0)
  else
    ver_epoch=$(date -d "${ver_date//./-}" "+%s" 2>/dev/null || echo 0)
  fi

  local now; now=$(date +%s)
  local days_old=$(( (now - ver_epoch) / 86400 ))
  if (( days_old > YTDLP_MAX_AGE_DAYS )); then
    _warn "yt-dlp is ${days_old} days old (${ver_str}) â€” run: m update"
  fi
}

# â”€â”€ audio device detection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
_detect_audio_devices() {
  [[ "$OS" != "mac" ]] && return
  [[ -z "$AUDIO_DEVICE_SPEAKERS"   ]] && AUDIO_DEVICE_SPEAKERS="coreaudio/BuiltInSpeakerDevice"
  [[ -z "$AUDIO_DEVICE_HEADPHONES" ]] && AUDIO_DEVICE_HEADPHONES="coreaudio/BuiltInHeadphoneOutputDevice"
}
_detect_audio_devices

# â”€â”€ daemon management â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# FIX #3 â€” _start uses atomic mkdir lock, not plain touch
_start() {
  [ -S "$SOCKET" ] && return 0

  # Atomic lock via mkdir
  if ! _lock "$LOCK_FILE" 5; then
    # Lock held by another process â€” wait for socket to appear
    _info "waiting for daemon to start..."
    for i in $(seq 1 30); do
      sleep 0.3
      [ -S "$SOCKET" ] && return 0
    done
    _die "daemon failed to start (lock timeout)"
  fi

  # Re-check after acquiring lock (another process may have started it)
  if [ -S "$SOCKET" ]; then
    _unlock "$LOCK_FILE"
    return 0
  fi

  _info "starting daemon..."

  local device_flag=""
  [[ -n "$AUDIO_DEVICE_SPEAKERS" ]] && device_flag="--audio-device=$AUDIO_DEVICE_SPEAKERS"

  # FIX #20 â€” mpv stderr to log file
  "$MPV" --no-video --idle=yes \
    --input-ipc-server="$SOCKET" \
    --script-opts=ytdl_hook-ytdl_path="$YTDLP" \
    ${device_flag:+"$device_flag"} \
    --volume="$DEFAULT_VOLUME" \
    --quiet --really-quiet \
    --ytdl-format="bestaudio/best" \
    --cache=yes --cache-secs=60 \
    --demuxer-max-bytes=50MiB \
    --prefetch-playlist=yes \
    --save-position-on-quit=no \
    2>>"$MPV_LOG" &
  local mpv_pid=$!
  disown $mpv_pid
  echo $mpv_pid > "$MPV_PID_FILE"

  for i in $(seq 1 30); do
    sleep 0.3
    if [ -S "$SOCKET" ]; then
      _unlock "$LOCK_FILE"
      return 0
    fi
  done

  _unlock "$LOCK_FILE"
  rm -f "$MPV_PID_FILE"
  _die "mpv daemon failed to start â€” check: $MPV_LOG"
}

# v4-A â€” _need probes the socket with a live IPC call, not just [ -S ].
# A stale socket file (mpv crashed) passes [ -S ] but fails IPC â€” we catch it.
_need() {
  if [ ! -S "$SOCKET" ]; then
    _die "daemon not running â€” run: m start"
  fi
  # Probe with a real IPC command; timeout via socat's built-in deadline
  if ! echo '{"command":["get_version"]}' \
        | "$SOCAT" -t 2 - "$SOCKET" >/dev/null 2>&1; then
    _die "daemon socket exists but mpv is unresponsive â€” run: m stop && m start"
  fi
}

# â”€â”€ IPC helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
_cmd() {
  echo "$1" | "$SOCAT" - "$SOCKET" 2>/dev/null
}

_silent() {
  echo "$1" | "$SOCAT" - "$SOCKET" >/dev/null 2>&1
}

# FIX #11 â€” retry wrapper for critical IPC commands (up to 3 attempts)
_silent_retry() {
  local json="$1" attempts="${2:-3}" i
  for i in $(seq 1 $attempts); do
    if echo "$json" | "$SOCAT" - "$SOCKET" >/dev/null 2>&1; then
      return 0
    fi
    sleep 0.1
  done
  return 1
}

_get() {
  local raw
  raw=$(_cmd "{\"command\":[\"get_property\",\"$1\"]}")
  echo "$raw" | "$JQ" -r '.data // empty' 2>/dev/null
}

# v4-H â€” batch multiple properties in one IPC round-trip
# Fallback correctly detects per-property errors:
# get_property_list returns {"data": {"prop": value, "prop2": "error"}} â€”
# individual unavailable properties get the string "error" as their value,
# NOT a top-level .error field. We check for a successful .data object,
# and fall back per-property if the entire call fails or .data is absent.
_get_multi() {
  local props_json
  props_json=$(printf '"%s",' "$@" | sed 's/,$//')
  local raw
  raw=$(_cmd "{\"command\":[\"get_property_list\",[${props_json}]]}" 2>/dev/null)
  # Fall back if get_property_list is unsupported (old mpv) or socket error
  if ! echo "$raw" | "$JQ" -e '.data | type == "object"' >/dev/null 2>&1; then
    local result="{"
    local first=1
    for prop in "$@"; do
      local val; val=$(_get "$prop")
      [[ $first -eq 0 ]] && result="${result},"
      result="${result}\"${prop}\":$(echo "$val" | "$JQ" -Rn 'input' 2>/dev/null || echo "null")"
      first=0
    done
    result="${result}}"
    echo "$result"
  else
    echo "$raw" | "$JQ" '.data // {}' 2>/dev/null
  fi
}

# v4-G â€” _wait_prop: max raised to 60 iterations; backoff fixed.
# Old formula: sleep "0.$(printf '%03d' $sleep_ms)" broke above 999ms and
# the +50ms linear ramp was too slow for poor connections (~7.5s total).
# New formula: uses proper decimal sleep; doubles every 10 steps (100â†’200â†’400ms).
_wait_prop() {
  local prop="$1" max="${2:-60}" val
  local spinner=('â ‹' 'â ™' 'â ¹' 'â ¸' 'â ¼' 'â ´' 'â ¦' 'â §' 'â ‡' 'â ')
  local si=0 sleep_ms=100
  for i in $(seq 1 "$max"); do
    val=$(_get "$prop")
    if [ -n "$val" ]; then
      printf '\r\e[2K' >&2
      echo "$val"
      return 0
    fi
    printf '\r\e[2K  %s buffering...' "${spinner[$((si % ${#spinner[@]}))]}" >&2
    si=$(( si + 1 ))
    # Double sleep every 10 iterations: 100ms â†’ 200ms â†’ 400ms, capped at 800ms
    (( i % 10 == 0 && sleep_ms < 800 )) && sleep_ms=$(( sleep_ms * 2 ))
    # Use awk for portable decimal sleep that works at any ms value
    awk "BEGIN{exit system(\"sleep \" $sleep_ms/1000)}" 2>/dev/null || sleep 0.2
  done
  printf '\r\e[2K' >&2
  echo ""
}

# Safe IPC using jq to build JSON â€” prevents injection from titles/URLs
_ipc_cmd() {
  local cmd_json
  cmd_json=$("$JQ" -cn --args '{"command":$ARGS.positional}' -- "$@")
  _silent_retry "$cmd_json"
}

_ipc_loadfile() {
  local url="$1" mode="${2:-append-play}"
  local json
  json=$("$JQ" -cn --arg url "$url" --arg mode "$mode" \
    '{"command":["loadfile",$url,$mode]}')
  _silent_retry "$json"
}

# â”€â”€ search & pick (with cache) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# v4-T â€” include $USER in cache key to prevent collisions on shared filesystems
# (e.g. NFS home dirs where multiple users share MUSIC_ROOT)
_cache_key() {
  printf '%s\0%s' "${USER:-$(id -un)}" "$1" | _md5 | tr -d ' \n'
}

_cache_age() {
  local f="$1"
  [ -f "$f" ] || { echo 9999; return; }
  echo $(( $(date +%s) - $(_mtime "$f") ))
}

# FIX #5 â€” validate result count before caching
_pick() {
  local query="$1"
  local key="$CACHE_DIR/$(_cache_key "$query").cache"
  local results

  if [ -f "$key" ] && [ "$(_cache_age "$key")" -lt "$CACHE_TTL" ]; then
    results=$(cat "$key")
  else
    _info "searching..."
    results=$("$YTDLP" "ytsearch${SEARCH_RESULTS}:$query" \
      --print "%(title)s | %(duration_string)s | %(webpage_url)s" \
      --no-download --no-warnings 2>/dev/null)

    # FIX #5: only cache if we got at least 1 valid result line (has a URL)
    local valid_count; valid_count=$(echo "$results" | grep -cE 'https?://' 2>/dev/null || echo 0)
    if [[ -n "$results" ]] && (( valid_count >= 1 )); then
      echo "$results" > "$key"
    else
      # Don't cache partial/empty results
      rm -f "$key"
    fi
  fi

  [ -z "$results" ] && { _warn "no results for: $query"; return 1; }

  echo "$results" | "$FZF" \
    --height 55% --reverse \
    --prompt "ğŸµ " \
    --header "ENTER select Â· ESC cancel Â· cached if instant" \
    --preview 'echo {} | sed "s/ | /\n/g"' \
    --preview-window=down:3:wrap \
    --ansi \
  | awk -F ' \| ' '{print $NF}'
}

# â”€â”€ history helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# v4-J â€” history trim: use tail -n (single read, no double _tac pipe)
# Old double _tac was wasteful and could read a partially-written file on the
# second pass. tail -n reads once, atomically from EOF.
_log_history() {
  local title="$1" url="$2"
  [ -z "$url" ] && return

  if _lock "$HISTORY_LOCK" 3; then
    printf '%s\t%s\t%s\n' "$(date '+%Y-%m-%d %H:%M')" "$title" "$url" >> "$HISTORY_FILE"
    local lines; lines=$(wc -l < "$HISTORY_FILE" | tr -d ' ')
    if [ "$lines" -gt "$HISTORY_MAX" ]; then
      local tmpf; tmpf=$(mktemp "$HISTORY_FILE.XXXXXX")
      tail -n "$HISTORY_MAX" "$HISTORY_FILE" > "$tmpf" \
        && mv "$tmpf" "$HISTORY_FILE" \
        || rm -f "$tmpf"
    fi
    _unlock "$HISTORY_LOCK"
  else
    # Lock timed out â€” append without trimming
    printf '%s\t%s\t%s\n' "$(date '+%Y-%m-%d %H:%M')" "$title" "$url" >> "$HISTORY_FILE"
  fi

  # v4-L â€” disown scrobble bg job so SIGHUP on parent exit cannot kill it
  _scrobble "$title" "$url" &
  disown $!
}

# FIX #23 â€” scrobble stub (no-op unless SCROBBLE_URL is set in config)
_scrobble() {
  [[ -z "${SCROBBLE_URL:-}" ]] && return 0
  local title="$1" url="$2"
  # Requires curl; silently skip if unavailable
  command -v curl >/dev/null 2>&1 || return 0
  local payload
  payload=$("$JQ" -cn \
    --arg title "$title" \
    --arg url "$url" \
    --arg ts "$(date +%s)" \
    '{listen_type:"single",payload:[{listened_at:($ts|tonumber),track_metadata:{track_name:$title,additional_info:{media_player:"m-cli",origin_url:$url}}}]}')
  curl -s -X POST "$SCROBBLE_URL" \
    -H "Content-Type: application/json" \
    -d "$payload" >/dev/null 2>&1 || true
}

# â”€â”€ extract clean YouTube URL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
_clean_url() {
  local url="$1"
  local vid

  vid=$(printf '%s' "$url" | grep -oE '[?&]v=([A-Za-z0-9_-]{11})' | head -1 | cut -d= -f2)

  if [ -z "$vid" ]; then
    vid=$(printf '%s' "$url" | grep -oE 'youtu\.be/([A-Za-z0-9_-]{11})' | head -1 \
          | grep -oE '[A-Za-z0-9_-]{11}$')
  fi

  [ -n "$vid" ] && echo "https://www.youtube.com/watch?v=$vid" || echo "$url"
}

# â”€â”€ local file detection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
_is_local_file() {
  local arg="$1"
  [[ -f "$arg" || "$arg" == /* || "$arg" == ./* || "$arg" == ../* ]] && return 0
  return 1
}

# â”€â”€ subcommands â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# â”€â”€ v4-O: Queue auto-snapshot â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Saves current mpv queue to $QUEUE_SNAPSHOT after every track change.
# Provides crash recovery via: m queue-restore
_queue_snapshot() {
  [ ! -S "$SOCKET" ] && return
  local raw; raw=$(_cmd '{"command":["get_property","playlist"]}' 2>/dev/null)
  [ -z "$raw" ] && return
  local urls; urls=$(echo "$raw" | "$JQ" -r '.data[].filename // empty' 2>/dev/null)
  [ -z "$urls" ] && return
  local tmpf; tmpf=$(mktemp "$DATA_DIR/snap.XXXXXX")
  echo "$urls" > "$tmpf" && mv "$tmpf" "$QUEUE_SNAPSHOT" || rm -f "$tmpf"
}

do_queue_restore() {
  [ -f "$QUEUE_SNAPSHOT" ] || { _warn "no queue snapshot found â€” nothing to restore"; return; }
  local count; count=$(grep -c . "$QUEUE_SNAPSHOT" 2>/dev/null || echo 0)
  [ "$count" -eq 0 ] && { _warn "queue snapshot is empty"; return; }
  _start
  _silent '{"command":["playlist-clear"]}'
  local loaded=0
  while IFS= read -r line; do
    [ -z "$line" ] && continue
    _ipc_loadfile "$line" "append-play"
    loaded=$(( loaded + 1 ))
  done < "$QUEUE_SNAPSHOT"
  _ok "restored queue: ${loaded} tracks  (use: m now)"
}

do_play() {
  _start
  local url

  # v4-I â€” resolve URL BEFORE clearing the queue.
  # Previously the queue was cleared first, so ESC in fzf or search failure
  # would destroy the user's queue with no recovery. Now we confirm a valid
  # URL exists before touching the queue state.
  if _is_local_file "$1"; then
    url="$1"
    [[ -f "$url" ]] || { _err "file not found: $url"; return 1; }
    _info "loading local file..."
  else
    url=$(_pick "$1") || return 1
  fi

  [ -z "$url" ] && { _warn "cancelled"; return; }

  # Safe to clear now â€” we have a confirmed URL
  _silent '{"command":["playlist-clear"]}'
  _info "buffering..."
  _ipc_loadfile "$url" "replace"
  local title; title=$(_wait_prop media-title 60)
  _ok "â–¶  ${title:-unknown}"
  _log_history "${title:-unknown}" "$(_clean_url "$url")"
  # v4-O â€” snapshot queue after every play action
  _queue_snapshot
}

# FIX #31 â€” do_add deduplication guard
do_add() {
  _start
  local url

  if _is_local_file "$1"; then
    url="$1"
    [[ -f "$url" ]] || { _err "file not found: $url"; return 1; }
  else
    url=$(_pick "$1") || return 1
  fi

  [ -z "$url" ] && { _warn "cancelled"; return; }

  # Dedup: check if this URL is already in the queue
  local existing
  existing=$(_cmd '{"command":["get_property","playlist"]}' \
    | "$JQ" -r '.data[].filename' 2>/dev/null | grep -cF "$url" 2>/dev/null || echo 0)
  if (( existing > 0 )); then
    _warn "already in queue â€” use -f to force add"
    return
  fi

  _ipc_loadfile "$url" "append-play"
  _ok "â• added to queue"
  _queue_snapshot
}

# Force-add variant (bypass dedup)
do_add_force() {
  _start
  local url

  if _is_local_file "$1"; then
    url="$1"
    [[ -f "$url" ]] || { _err "file not found: $url"; return 1; }
  else
    url=$(_pick "$1") || return 1
  fi

  [ -z "$url" ] && { _warn "cancelled"; return; }
  _ipc_loadfile "$url" "append-play"
  _ok "â• force-added to queue"
  _queue_snapshot
}

do_pause() {
  _need
  _silent '{"command":["cycle","pause"]}'
  local p; p=$(_get pause)
  [ "$p" = "true" ] && _info "â¸  paused" || _info "â–¶  resumed"
}

do_next() {
  _need
  _silent '{"command":["playlist-next"]}'
  local title; title=$(_wait_prop media-title 20)
  _ok "â­  ${title:-end of queue}"
}

do_prev() {
  _need
  _silent '{"command":["playlist-prev"]}'
  local title; title=$(_wait_prop media-title 20)
  _ok "â®  ${title:-beginning of queue}"
}

# v4-K â€” do_stop removes LOCK_FILE_D (the mkdir sentinel) in addition to
# LOCK_FILE (the PID file). Previously do_stop left the .d directory behind,
# causing _lock's stale-lock detection to fail on next m start because the
# PID file was gone but the sentinel directory blocked the mkdir attempt.
do_stop() {
  # Kill background txt queuing job first
  _txt_kill_bg_job

  # Cancel any active sleep timer
  _sleep_timer_cancel

  if [[ -f "$MPV_PID_FILE" ]]; then
    local pid; pid=$(cat "$MPV_PID_FILE" 2>/dev/null)
    if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
      kill "$pid" 2>/dev/null
      for i in $(seq 1 20); do
        sleep 0.1
        kill -0 "$pid" 2>/dev/null || break
      done
      kill -9 "$pid" 2>/dev/null
    fi
    rm -f "$MPV_PID_FILE"
  else
    pkill -f "input-ipc-server=${SOCKET}" 2>/dev/null
  fi
  rm -f "$SOCKET" "$LOCK_FILE"
  rmdir "$LOCK_FILE_D" 2>/dev/null   # v4-K: clear sentinel to unblock next _lock
  _ok "stopped"
}

do_start() {
  _start && _ok "daemon ready"
}

do_vol() {
  _need
  case "${1:-}" in
    +)
      _silent "{\"command\":[\"add\",\"volume\",${VOLUME_STEP}]}"
      local v; v=$(_get volume | awk '{printf "%.0f",$1}')
      (( v > 150 )) && _silent '{"command":["set_property","volume",150]}'
      ;;
    -)
      _silent "{\"command\":[\"add\",\"volume\",-${VOLUME_STEP}]}"
      local v; v=$(_get volume | awk '{printf "%.0f",$1}')
      (( v < 0 )) && _silent '{"command":["set_property","volume",0]}'
      ;;
    '')
      local v; v=$(_get volume)
      _info "volume: $(echo "$v" | awk '{printf "%.0f%%",$1}')"
      return
      ;;
    *)
      [[ "${1:-}" =~ ^[0-9]+$ ]] || { _err "usage: m vol [0-150 | + | -]"; return 1; }
      (( $1 > 150 )) && { _err "max volume is 150"; return 1; }
      _silent "{\"command\":[\"set_property\",\"volume\",$1]}"
      ;;
  esac
  local v; v=$(_get volume)
  _info "volume: $(echo "$v" | awk '{printf "%.0f%%",$1}')"
}

# FIX #8 â€” do_seek rewritten with explicit, unambiguous case branches
do_seek() {
  _need
  [ -z "${1:-}" ] && { _err "usage: m seek [+N | -N | N | MM:SS]"; return 1; }
  local input="$1"

  # Convert MM:SS or [+-]MM:SS â†’ integer seconds preserving sign
  local secs="$input"
  if echo "$input" | grep -qE '^[+-]?[0-9]+:[0-9]{2}$'; then
    local sign="" ts="$input"
    [[ "$input" == +* ]] && { sign="+"; ts="${input#+}"; }
    [[ "$input" == -* ]] && { sign="-"; ts="${input#-}"; }
    local m s
    m=$(echo "$ts" | cut -d: -f1 | sed 's/^0*//' ); m=${m:-0}
    s=$(echo "$ts" | cut -d: -f2 | sed 's/^0*//' ); s=${s:-0}
    secs="${sign}$(( m * 60 + s ))"
  fi

  # Now dispatch cleanly: relative for +/- prefix, absolute for bare number
  case "$secs" in
    +*)
      # Explicit forward seek
      local n="${secs#+}"
      [[ "$n" =~ ^[0-9]+$ ]] || { _err "invalid seek value: $input"; return 1; }
      _silent "{\"command\":[\"seek\",\"${n}\",\"relative\"]}"
      ;;
    -*)
      # Explicit backward seek
      local n="${secs#-}"
      [[ "$n" =~ ^[0-9]+$ ]] || { _err "invalid seek value: $input"; return 1; }
      _silent "{\"command\":[\"seek\",\"-${n}\",\"relative\"]}"
      ;;
    *)
      # Bare integer â†’ absolute seek
      [[ "$secs" =~ ^[0-9]+$ ]] || { _err "invalid seek value: $input"; return 1; }
      _silent "{\"command\":[\"seek\",\"$secs\",\"absolute\"]}"
      ;;
  esac

  sleep 0.1
  local pos; pos=$(_get time-pos)
  local dur; dur=$(_get duration)
  pos=$(echo "$pos" | awk '{printf "%d:%02d",$1/60,$1%60}' 2>/dev/null)
  dur=$(echo "$dur" | awk '{printf "%d:%02d",$1/60,$1%60}' 2>/dev/null)
  _info "â© ${pos} / ${dur}"
}

do_speed() {
  _need
  case "${1:-}" in
    +)  _silent '{"command":["multiply","speed",1.1]}' ;;
    -)  _silent '{"command":["multiply","speed",0.909090909]}' ;;
    r)  _silent '{"command":["set_property","speed",1.0]}'; _info "speed: 1.0x"; return ;;
    '')  { _err "usage: m speed [0.25-4.0 | + | - | r]"; return 1; } ;;
    *)
      [[ "${1:-}" =~ ^[0-9]+(\.[0-9]+)?$ ]] || { _err "usage: m speed [0.25-4.0 | + | - | r]"; return 1; }
      (( $(echo "$1 < 0.25" | awk '{print ($1<0.25)?1:0}') )) && { _err "min speed is 0.25"; return 1; }
      (( $(echo "$1 > 4.0"  | awk '{print ($1>4.0)?1:0}') )) && { _err "max speed is 4.0"; return 1; }
      _silent "{\"command\":[\"set_property\",\"speed\",$1]}"
      ;;
  esac
  local sp; sp=$(_get speed)
  _info "speed: $(echo "$sp" | awk '{printf "%.3fx",$1}')"
}

do_hp() {
  _need
  [[ -z "${AUDIO_DEVICE_HEADPHONES:-}" ]] && { _err "headphone device not configured â€” set AUDIO_DEVICE_HEADPHONES in $CONFIG_FILE"; return 1; }
  _silent "{\"command\":[\"set_property\",\"audio-device\",\"$AUDIO_DEVICE_HEADPHONES\"]}"
  _ok "ğŸ§ headphones"
}

do_sp() {
  _need
  [[ -z "${AUDIO_DEVICE_SPEAKERS:-}" ]] && { _err "speaker device not configured â€” set AUDIO_DEVICE_SPEAKERS in $CONFIG_FILE"; return 1; }
  _silent "{\"command\":[\"set_property\",\"audio-device\",\"$AUDIO_DEVICE_SPEAKERS\"]}"
  _ok "ğŸ”Š speakers"
}

do_shuffle() { _need; _silent '{"command":["playlist-shuffle"]}'; _ok "ğŸ”€ shuffled"; }

do_repeat() {
  _need
  _silent '{"command":["cycle","loop-playlist"]}'
  local state; state=$(_get loop-playlist)
  _info "ğŸ” repeat: ${state}"
}

do_repeat_one() {
  _need
  _silent '{"command":["cycle","loop-file"]}'
  local state; state=$(_get loop-file)
  _info "ğŸ”‚ repeat-one: ${state}"
}

do_clear() { _need; _silent '{"command":["playlist-clear"]}'; _ok "ğŸ—‘  queue cleared"; }

do_now() {
  _need
  local title pos dur paused speed
  title=$(_get media-title)
  [ -z "$title" ] && { _warn "nothing playing"; return; }
  pos=$(_get time-pos | awk '{printf "%d:%02d",$1/60,$1%60}' 2>/dev/null)
  dur=$(_get duration   | awk '{printf "%d:%02d",$1/60,$1%60}' 2>/dev/null)
  paused=$(_get pause)
  speed=$(_get speed | awk '{printf "%.2f",$1}')
  local icon="â–¶"; [ "$paused" = "true" ] && icon="â¸"
  local pl_pos; pl_pos=$(_get playlist-playing-pos)
  local pl_count; pl_count=$(_cmd '{"command":["get_property","playlist"]}' | "$JQ" '.data|length' 2>/dev/null)
  echo ""
  echo "  ${icon}  ${Y}${title}${X}"
  echo "  ${W}${pos}${X} / ${W}${dur}${X}   speed: ${speed}x   queue: $((pl_pos+1))/${pl_count:-?}"
  echo ""
}

# FIX #9 â€” _m_bar_cleanup prefixed to avoid global namespace collision
# FIX #17 â€” batch IPC into single round-trip using get_property_list
# FIX #29 â€” volume displayed in bar
do_bar() {
  _need
  local title; title=$(_get media-title)
  [ -z "$title" ] && { _warn "nothing playing"; return; }

  tput civis 2>/dev/null

  local _m_bar_cleanup_done=0
  _m_bar_cleanup() {
    if [[ $_m_bar_cleanup_done -eq 0 ]]; then
      _m_bar_cleanup_done=1
      printf '\n\n\n'
      tput cnorm 2>/dev/null
    fi
  }
  trap '_m_bar_cleanup' INT TERM

  local tw; tw=$(tput cols 2>/dev/null || echo 80)
  local bar_w=$(( tw - 24 ))
  (( bar_w < 10 )) && bar_w=10

  while true; do
    # FIX #17 â€” single IPC call for all bar properties
    local raw_pl raw_props
    raw_props=$(_cmd '{"command":["get_property_list",["time-pos","duration","pause","speed","media-title","loop-playlist","loop-file","volume","playlist-playing-pos"]]}' 2>/dev/null)

    # Parse each field; fall back to individual _get if batch not available
    local pos dur paused speed title2 repeat loop_one vol pl_pos
    if echo "$raw_props" | "$JQ" -e '.data' >/dev/null 2>&1; then
      pos=$(echo "$raw_props"      | "$JQ" -r '.data["time-pos"]         // empty' 2>/dev/null)
      dur=$(echo "$raw_props"      | "$JQ" -r '.data["duration"]         // empty' 2>/dev/null)
      paused=$(echo "$raw_props"   | "$JQ" -r '.data["pause"]            // empty' 2>/dev/null)
      speed=$(echo "$raw_props"    | "$JQ" -r '.data["speed"]            // 1'     2>/dev/null)
      title2=$(echo "$raw_props"   | "$JQ" -r '.data["media-title"]      // ""'    2>/dev/null)
      repeat=$(echo "$raw_props"   | "$JQ" -r '.data["loop-playlist"]    // "no"'  2>/dev/null)
      loop_one=$(echo "$raw_props" | "$JQ" -r '.data["loop-file"]        // "no"'  2>/dev/null)
      vol=$(echo "$raw_props"      | "$JQ" -r '.data["volume"]           // 80'    2>/dev/null)
    else
      pos=$(_get time-pos)
      dur=$(_get duration)
      paused=$(_get pause)
      speed=$(_get speed | awk '{printf "%.2f",$1}')
      title2=$(_get media-title)
      repeat=$(_get loop-playlist)
      loop_one=$(_get loop-file)
      vol=$(_get volume | awk '{printf "%.0f",$1}')
    fi

    speed=$(echo "$speed" | awk '{printf "%.2f",$1}')
    vol=$(echo "$vol" | awk '{printf "%.0f",$1}')

    [ -z "$pos" ] || [ -z "$dur" ] && break

    local pos_i dur_i
    pos_i=$(printf '%.0f' "$pos" 2>/dev/null || echo 0)
    dur_i=$(printf '%.0f' "$dur" 2>/dev/null || echo 1)
    (( dur_i < 1 )) && dur_i=1

    local pct=$(( pos_i * 100 / dur_i ))
    local filled=$(( pos_i * bar_w / dur_i ))
    local empty=$(( bar_w - filled ))
    (( filled < 0 )) && filled=0
    (( empty  < 0 )) && empty=0

    local pos_fmt; pos_fmt=$(awk "BEGIN{printf \"%d:%02d\", $pos_i/60, $pos_i%60}")
    local dur_fmt; dur_fmt=$(awk "BEGIN{printf \"%d:%02d\", $dur_i/60, $dur_i%60}")
    local rem_i=$(( dur_i - pos_i ))
    local rem_fmt; rem_fmt=$(awk "BEGIN{printf \"-%d:%02d\", $rem_i/60, $rem_i%60}")

    local icon="â–¶"; [ "$paused" = "true" ] && icon="â¸"
    local rep_icon=""
    [[ "$loop_one" != "no" && -n "$loop_one" ]] && rep_icon=" ğŸ”‚"
    [[ "$repeat"   != "no" && -n "$repeat"   ]] && rep_icon=" ğŸ”"

    local bar_filled bar_empty
    bar_filled=$(printf '%*s' "$filled" '' | tr ' ' 'â”')
    bar_empty=$(printf '%*s'  "$empty"  '' | tr ' ' 'â”€')

    printf '\r\e[2K'
    printf "\e[0;36m  ${icon}  \e[1;37m%.${tw}s\e[0m" "${title2}${rep_icon}"
    printf '\n\r\e[2K'
    printf "  \e[0;36m%s\e[0m\e[2m%s\e[0m  \e[0;33m%s\e[0m / \e[0;37m%s\e[0m  \e[2m(%s)\e[0m" \
      "$bar_filled" "$bar_empty" "$pos_fmt" "$dur_fmt" "$rem_fmt"
    printf '\n\r\e[2K'
    # FIX #29 â€” show volume in bar
    printf "  \e[2mspd:%sx  vol:%s%%  %d%%  p=pause  n/b=skip  ,/.=seek  +/-=vol  r=rpt  q=quit\e[0m" \
      "$speed" "$vol" "$pct"
    printf '\e[2A'

    local key
    if read -r -s -k1 -t 0.5 key 2>/dev/null; then
      case "$key" in
        q|Q|$'\e') break ;;
        p) _silent '{"command":["cycle","pause"]}' ;;
        n) _silent '{"command":["playlist-next"]}'; sleep 0.4 ;;
        b) _silent '{"command":["playlist-prev"]}'; sleep 0.4 ;;
        .) _silent '{"command":["seek","10","relative"]}' ;;
        ,) _silent '{"command":["seek","-10","relative"]}' ;;
        +) _silent "{\"command\":[\"add\",\"volume\",${VOLUME_STEP}]}" ;;
        -) _silent "{\"command\":[\"add\",\"volume\",-${VOLUME_STEP}]}" ;;
        r) _silent '{"command":["cycle","loop-playlist"]}' ;;
        1) _silent '{"command":["cycle","loop-file"]}' ;;
      esac
    fi
  done

  _m_bar_cleanup
  trap - INT TERM
}

do_scrub() {
  _need
  local title pos dur
  title=$(_get media-title)
  [ -z "$title" ] && { _warn "nothing playing"; return; }
  dur=$(_get duration)
  pos=$(_get time-pos)
  [ -z "$dur" ] && { _warn "duration unavailable (still buffering?)"; return; }

  local dur_i; dur_i=$(printf '%.0f' "$dur")
  local pos_i; pos_i=$(printf '%.0f' "${pos:-0}")
  (( dur_i < 1 )) && { _warn "track too short to scrub"; return; }

  local step=5
  (( dur_i / step > 500 )) && step=$(( dur_i / 500 + 1 ))

  local lines=()
  local t=0
  while (( t <= dur_i )); do
    local mm ss pct bar_fill bar_empty filled_w empty_w
    mm=$(( t / 60 )); ss=$(( t % 60 ))
    pct=$(( t * 100 / dur_i ))
    filled_w=$(( pct * 30 / 100 ))
    empty_w=$(( 30 - filled_w ))
    bar_fill=$(printf '%*s' "$filled_w" '' | tr ' ' 'â–ˆ')
    bar_empty=$(printf '%*s' "$empty_w" '' | tr ' ' 'â–‘')
    local marker="  "
    (( t >= pos_i - step/2 && t <= pos_i + step/2 )) && marker="â–¶ "
    lines+=("$(printf '%s%02d:%02d  [%s%s]  %3d%%' "$marker" "$mm" "$ss" "$bar_fill" "$bar_empty" "$pct")")
    t=$(( t + step ))
  done

  local chosen
  chosen=$(printf '%s\n' "${lines[@]}" | "$FZF" \
    --height 70% --reverse \
    --prompt "â±  scrub > " \
    --header "â–¶ marks current pos Â· ENTER to jump Â· ESC cancel" \
    --no-sort)

  [ -z "$chosen" ] && { _warn "cancelled"; return; }

  local ts; ts=$(echo "$chosen" | grep -oE '[0-9]+:[0-9]{2}' | head -1)
  [ -z "$ts" ] && { _err "could not parse timestamp"; return 1; }

  local m s target_secs
  m=$(echo "$ts" | cut -d: -f1 | sed 's/^0*//' ); m=${m:-0}
  s=$(echo "$ts" | cut -d: -f2 | sed 's/^0*//' ); s=${s:-0}
  target_secs=$(( m * 60 + s ))

  _silent "{\"command\":[\"seek\",\"$target_secs\",\"absolute\"]}"
  sleep 0.1
  local new_pos; new_pos=$(_get time-pos | awk '{printf "%d:%02d",$1/60,$1%60}')
  _ok "jumped to ${new_pos}  /  $(awk "BEGIN{printf \"%d:%02d\",$dur_i/60,$dur_i%60}")"
}

do_queue() {
  _need
  local pl current_idx n
  pl=$(_cmd '{"command":["get_property","playlist"]}')
  n=$(echo "$pl" | "$JQ" '.data|length' 2>/dev/null)
  # playlist-playing-pos is 0-based array index (correct after shuffle too)
  current_idx=$(_get playlist-playing-pos)
  [ -z "$n" ] || [ "$n" = "0" ] && { _warn "queue empty"; return; }
  echo ""
  echo "  ${C}queue â€” ${n} tracks${X}"
  echo ""
  echo "$pl" | "$JQ" -r '.data | to_entries[] | [(.key|tostring), (.value.title // .value.filename)] | @tsv' 2>/dev/null \
    | while IFS=$'\t' read -r idx title; do
        if [ "$idx" = "$current_idx" ]; then
          echo "  ${G}â–¶ $((idx+1)). ${title}${X}"
        else
          echo "    $((idx+1)). ${title}"
        fi
      done
  echo ""
}

do_queue_move() {
  _need
  [[ -z "${1:-}" || -z "${2:-}" ]] && { _err "usage: m qmove <from_pos> <to_pos>  (1-based)"; return 1; }
  local from=$(( $1 - 1 )) to=$(( $2 - 1 ))
  _silent "{\"command\":[\"playlist-move\",${from},${to}]}"
  _ok "moved track $1 â†’ position $2"
}

do_queue_remove() {
  _need
  [[ -z "${1:-}" ]] && { _err "usage: m qrm <pos>  (1-based)"; return 1; }
  local pos=$(( $1 - 1 ))
  _silent "{\"command\":[\"playlist-remove\",${pos}]}"
  _ok "removed track $1 from queue"
}

do_status() {
  if [ ! -S "$SOCKET" ]; then
    echo ""
    echo "  ${R}â— stopped${X}   run: m start"
    echo ""
    return
  fi
  local title paused vol speed
  title=$(_get media-title)
  paused=$(_get pause)
  vol=$(_get volume | awk '{printf "%.0f",$1}')
  speed=$(_get speed | awk '{printf "%.2f",$1}')
  local pl_count; pl_count=$(_cmd '{"command":["get_property","playlist"]}' | "$JQ" '.data|length' 2>/dev/null)
  local repeat; repeat=$(_get loop-playlist)
  local loop_one; loop_one=$(_get loop-file)
  echo ""
  printf "  ${G}â— running${X}   vol:%s%%   speed:%sx   queue:%s tracks\n" "$vol" "$speed" "${pl_count:-0}"

  _txt_state_read
  if [ -n "$TXT_ACTIVE_FILE" ]; then
    _txt_read_lines "$TXT_ACTIVE_FILE"
    printf "  ${C}txt:${X} %s  [%s/%s]\n" "$(basename "$TXT_ACTIVE_FILE" .txt)" \
      "$(( TXT_ACTIVE_IDX + 1 ))" "${#TXT_LINES[@]}"
  fi

  # Show active sleep timer if any
  local timer_file="$DATA_DIR/sleep_timer_pid"
  if [[ -f "$timer_file" ]]; then
    local tpid; tpid=$(cat "$timer_file" 2>/dev/null)
    [[ -n "$tpid" ]] && kill -0 "$tpid" 2>/dev/null && printf "  ${Y}â²  sleep timer active${X}\n"
  fi

  [[ "$repeat"   != "no" && -n "$repeat"   ]] && printf "  ${Y}ğŸ” repeat-playlist on${X}\n"
  [[ "$loop_one" != "no" && -n "$loop_one" ]] && printf "  ${Y}ğŸ”‚ repeat-one on${X}\n"
  if [ -n "$title" ]; then
    local pos dur
    pos=$(_get time-pos | awk '{printf "%d:%02d",$1/60,$1%60}' 2>/dev/null)
    dur=$(_get duration   | awk '{printf "%d:%02d",$1/60,$1%60}' 2>/dev/null)
    [ "$paused" = "true" ] \
      && echo "  ${Y}â¸  ${title}${X}   ${pos}/${dur}" \
      || echo "  ${G}â–¶  ${title}${X}   ${pos}/${dur}"
  else
    echo "  ${W}idle â€” queue something with: m \"song name\"${X}"
  fi
  echo ""
}

# â”€â”€ like / love â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

do_like() {
  _need
  local title url clean
  title=$(_get media-title)
  url=$(_get path)
  [ -z "$url" ] && { _warn "nothing playing"; return; }
  clean=$(_clean_url "$url")
  if grep -qF "$clean" "$LIKES_FILE" 2>/dev/null; then
    _warn "already liked: $title"
    return
  fi
  printf '%s\t%s\t%s\n' "$(date '+%Y-%m-%d %H:%M')" "$title" "$clean" >> "$LIKES_FILE"
  _ok "â¤  liked: ${title}"
}

do_unlike() {
  [ -s "$LIKES_FILE" ] || { _warn "no likes yet"; return; }
  local line
  line=$("$FZF" \
    --height 50% --reverse \
    --prompt "ğŸ’” unlike > " \
    --header "ENTER to remove Â· ESC cancel" \
    --with-nth=2 --delimiter=$'\t' < "$LIKES_FILE")
  [ -z "$line" ] && { _warn "cancelled"; return; }
  local tmpf; tmpf=$(mktemp "$LIKES_FILE.XXXXXX")
  grep -vF "$line" "$LIKES_FILE" > "$tmpf" && mv "$tmpf" "$LIKES_FILE" || rm -f "$tmpf"
  _ok "removed from likes"
}

do_likes() {
  [ -s "$LIKES_FILE" ] || { _warn "no likes yet â€” use: m like"; return; }
  echo ""
  echo "  ${M}â¤  liked tracks${X}"
  echo ""
  awk -F'\t' '{print NR". "$2}' "$LIKES_FILE" | sed 's/^/  /'
  echo ""
}

do_love() {
  _need
  [ -s "$LIKES_FILE" ] || { _warn "no likes yet â€” use: m like while playing"; return; }
  local line; line=$(_shuf1 "$LIKES_FILE")
  [ -z "$line" ] && { _warn "likes file empty"; return; }
  local url title
  url=$(printf '%s' "$line" | awk -F'\t' '{print $3}')
  title=$(printf '%s' "$line" | awk -F'\t' '{print $2}')
  _start
  _silent '{"command":["playlist-clear"]}'
  _ipc_loadfile "$url" "replace"
  local actual_title; actual_title=$(_wait_prop media-title 30)
  _ok "â¤  â–¶  ${actual_title:-$title}"
}

do_likes_play() {
  _need
  [ -s "$LIKES_FILE" ] || { _warn "no likes yet"; return; }
  local line
  line=$("$FZF" \
    --height 50% --reverse \
    --prompt "â¤ play liked > " \
    --header "ENTER play Â· ESC cancel" \
    --with-nth=2 --delimiter=$'\t' < "$LIKES_FILE")
  [ -z "$line" ] && { _warn "cancelled"; return; }
  local url; url=$(printf '%s' "$line" | awk -F'\t' '{print $3}')
  _silent '{"command":["playlist-clear"]}'
  _ipc_loadfile "$url" "replace"
  local actual_title; actual_title=$(_wait_prop media-title 30)
  _ok "â–¶  ${actual_title:-playing}"
}

# â”€â”€ history â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# FIX #15 â€” do_history preview uses awk to avoid word-splitting on tab fields
do_history() {
  [ -s "$HISTORY_FILE" ] || { _warn "no history yet"; return; }
  local line url
  line=$(_tac "$HISTORY_FILE" | "$FZF" \
    --height 60% --reverse \
    --prompt "ğŸ•‘ history > " \
    --header "ENTER replay Â· ESC cancel" \
    --with-nth=1,2 --delimiter=$'\t' \
    --preview 'echo {} | awk -F"\t" "{printf \"Date:  %s\nTitle: %s\nURL:   %s\n\",\$1,\$2,\$3}"' \
    --preview-window=down:3:wrap)
  [ -z "$line" ] && { _warn "cancelled"; return; }
  url=$(printf '%s' "$line" | awk -F'\t' '{print $3}')
  [ -z "$url" ] && { _err "could not extract URL from history entry"; return 1; }
  _start
  _silent '{"command":["playlist-clear"]}'
  _ipc_loadfile "$url" "replace"
  local title; title=$(_wait_prop media-title 30)
  _ok "â–¶  ${title:-playing}"
}

do_history_clear() {
  printf "${Y}Clear all history? [y/N] ${X}"
  read -r ans
  [[ "$ans" =~ ^[Yy]$ ]] || { _warn "cancelled"; return; }
  > "$HISTORY_FILE"
  _ok "history cleared"
}

# â”€â”€ playlists â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

do_save() {
  _need
  [ -z "${1:-}" ] && { _err "usage: m save <name>"; return 1; }
  local name="$1"
  name=$(printf '%s' "$name" | tr ' ' '_' | tr -cd '[:alnum:]_-')
  [ -z "$name" ] && { _err "invalid playlist name"; return 1; }
  local file="$PLAYLIST_DIR/${name}.m3u"
  local tmpf; tmpf=$(mktemp "$PLAYLIST_DIR/${name}.XXXXXX")
  local count=0

  # FIX #1 â€” check jq result outside subshell, propagate failure properly
  local raw_playlist
  raw_playlist=$(_cmd '{"command":["get_property","playlist"]}')
  local urls
  urls=$(echo "$raw_playlist" | "$JQ" -r '.data[].filename' 2>/dev/null)
  if [[ -z "$urls" ]]; then
    rm -f "$tmpf"
    _err "queue is empty â€” nothing to save"
    return 1
  fi

  while IFS= read -r url; do
    [ -z "$url" ] && continue
    printf '%s\n' "$(_clean_url "$url")" >> "$tmpf"
    count=$(( count + 1 ))
  done <<< "$urls"

  if [[ $count -eq 0 ]]; then
    rm -f "$tmpf"
    _err "queue is empty â€” nothing to save"
    return 1
  fi
  mv "$tmpf" "$file"
  _ok "saved: ${name}  (${count} tracks)"
}

do_load() {
  [ -z "${1:-}" ] && { _err "usage: m load <n>"; return 1; }
  local f="$PLAYLIST_DIR/${1}.m3u"
  [ -f "$f" ] || { _err "playlist not found: $1"; return 1; }
  _start
  _silent '{"command":["playlist-clear"]}'

  # v4-C â€” build in-memory set of existing URLs from ONE IPC call (was O(nÂ²))
  # Previously each track triggered a full playlist re-fetch over IPC (~nÂ² calls).
  # Now we fetch once before the loop and grep against the local variable.
  local _existing_urls
  _existing_urls=$(_cmd '{"command":["get_property","playlist"]}' \
    | "$JQ" -r '.data[].filename // empty' 2>/dev/null || echo "")

  local count=0
  while IFS= read -r line; do
    [[ -z "$line" || "$line" == \#* ]] && continue

    # O(1) per track: grep in-memory, not live IPC each iteration
    if echo "$_existing_urls" | grep -qF "$line" 2>/dev/null; then
      _warn "skipping duplicate: $(basename "$line")"
      continue
    fi

    _ipc_loadfile "$line" "append-play"
    # Also dedup within this file's own tracks
    _existing_urls="${_existing_urls}"$'\n'"${line}"
    count=$(( count + 1 ))
  done < "$f"
  _ok "loaded: $1  (${count} tracks)"
  _info "first track buffering... use: m now"
  _queue_snapshot
}

do_playlists() {
  echo ""
  echo "  ${C}saved playlists:${X}"
  local found=0
  for f in "$PLAYLIST_DIR"/*.m3u(N); do
    local name; name=$(basename "$f" .m3u)
    local count; count=$(grep -cvE '^\s*(#|$)' "$f" 2>/dev/null || echo 0)
    echo "  âˆ™ ${W}${name}${X}  (${count} tracks)"
    found=1
  done
  [ $found -eq 0 ] && echo "  (none yet â€” use: m save <name>)"
  echo ""
}

do_playlist_del() {
  [ -z "${1:-}" ] && { _err "usage: m pldel <name>"; return 1; }
  local f="$PLAYLIST_DIR/${1}.m3u"
  [ -f "$f" ] || { _err "not found: $1"; return 1; }
  printf "${Y}Delete playlist '%s'? [y/N] ${X}" "$1"
  read -r ans
  [[ "$ans" =~ ^[Yy]$ ]] || { _warn "cancelled"; return; }
  rm "$f"
  _ok "deleted playlist: $1"
}

# â”€â”€ download â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# v4-P â€” do_dl: removed --quiet flag suppression; yt-dlp progress now shows.
# Added --progress and --console-title=no to ensure clean terminal output.
do_dl() {
  [ -z "${1:-}" ] && { _err "usage: m dl \"song query\""; return 1; }
  _info "searching to download..."
  local url; url=$(_pick "$1") || return 1
  [ -z "$url" ] && { _warn "cancelled"; return; }
  _info "downloading to $DOWNLOADS_DIR ..."
  echo ""
  "$YTDLP" "$url" \
    --extract-audio \
    --audio-format mp3 \
    --audio-quality 0 \
    --embed-thumbnail \
    --add-metadata \
    --embed-metadata \
    --output "$DOWNLOADS_DIR/%(title)s.%(ext)s" \
    --no-playlist \
    --progress \
    --console-title=no \
    --no-warnings
  local rc=$?
  echo ""
  if [[ $rc -ne 0 ]]; then
    _err "download failed (yt-dlp exit $rc) â€” check: m log"
    return 1
  fi
  _ok "download complete â†’ $DOWNLOADS_DIR"
}

do_dl_list() {
  echo ""
  echo "  ${C}downloads:${X}  $DOWNLOADS_DIR"
  echo ""
  local found=0
  for f in "$DOWNLOADS_DIR"/*.mp3(N) "$DOWNLOADS_DIR"/*.m4a(N) "$DOWNLOADS_DIR"/*.opus(N); do
    echo "  âˆ™ $(basename "$f")"
    found=1
  done
  [[ $found -eq 0 ]] && echo "  (none yet â€” use: m dl \"song name\")"
  echo ""
}

# â”€â”€ import YouTube playlist â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

do_import() {
  [ -z "${1:-}" ] && { _err "usage: m import \"https://youtube.com/playlist?list=...\""; return 1; }
  _info "fetching playlist metadata (this may take a moment)..."
  local tmpf; tmpf=$(mktemp "$PLAYLIST_DIR/import.XXXXXX")
  "$YTDLP" "$1" \
    --flat-playlist \
    --print "%(webpage_url)s" \
    --no-warnings 2>/dev/null > "$tmpf"
  local count; count=$(wc -l < "$tmpf" | tr -d ' ')
  if [[ $count -eq 0 ]]; then
    rm -f "$tmpf"
    _err "no tracks found â€” is the URL correct and the playlist public?"
    return 1
  fi
  printf "${C}Save as playlist name: ${X}"
  read -r pname
  pname=$(printf '%s' "$pname" | tr ' ' '_' | tr -cd '[:alnum:]_-')
  [ -z "$pname" ] && { rm -f "$tmpf"; _err "invalid name"; return 1; }

  # v4-R â€” guard against silently overwriting an existing playlist
  if [[ -f "$PLAYLIST_DIR/${pname}.m3u" ]]; then
    local existing_count; existing_count=$(grep -cvE '^\s*(#|$)' "$PLAYLIST_DIR/${pname}.m3u" 2>/dev/null || echo 0)
    printf "${Y}Playlist '%s' already exists (%s tracks). Overwrite? [y/N] ${X}" "$pname" "$existing_count"
    local ans; read -r ans
    if [[ ! "$ans" =~ ^[Yy]$ ]]; then
      rm -f "$tmpf"
      _warn "import cancelled â€” choose a different name or confirm overwrite"
      return 1
    fi
  fi

  mv "$tmpf" "$PLAYLIST_DIR/${pname}.m3u"
  _ok "imported: ${pname}  (${count} tracks)  â†’  m load ${pname}"
}

# â”€â”€ txt playlist system â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# NOTE: This script is zsh-only (shebang: #!/usr/bin/env zsh).
# FIX #6 â€” zsh arrays are 1-based. This is intentional and documented.
# All TXT_LINES accesses use 1-based indexing consistently.
# mpv playlist-playing-pos is 0-based (mpv's own API) â€” those are kept 0-based.

_txt_state_write() {
  local file="$1" idx="$2"
  printf '%s\t%s\n' "$file" "$idx" > "$TXT_STATE_FILE"
}

_txt_state_read() {
  TXT_ACTIVE_FILE=""
  TXT_ACTIVE_IDX=0
  [ -f "$TXT_STATE_FILE" ] || return
  TXT_ACTIVE_FILE=$(awk -F'\t' '{print $1}' "$TXT_STATE_FILE")
  TXT_ACTIVE_IDX=$(awk -F'\t' '{print $2}' "$TXT_STATE_FILE")
  [ -f "$TXT_ACTIVE_FILE" ] || { TXT_ACTIVE_FILE=""; TXT_ACTIVE_IDX=0; }
}

_txt_read_lines() {
  local f="$1"
  TXT_LINES=()
  while IFS= read -r line; do
    line="${line#"${line%%[! ]*}"}"
    line="${line%"${line##*[! ]}"}"
    [[ -z "$line" || "$line" == \#* ]] && continue
    TXT_LINES+=("$line")
  done < "$f"
}

_txt_resolve() {
  local arg="$1"
  [ -f "$arg" ] && { echo "$arg"; return; }
  [ -f "$TXTS_DIR/${arg}.txt" ] && { echo "$TXTS_DIR/${arg}.txt"; return; }
  [ -f "$TXTS_DIR/${arg}" ] && { echo "$TXTS_DIR/${arg}"; return; }
  echo ""
}

_txt_search_and_play_line() {
  local query="$1"
  local key="$CACHE_DIR/$(_cache_key "$query").cache"
  local results url

  # v4-D â€” use $SEARCH_RESULTS config instead of hardcoded ytsearch5
  # Previously this always used 5 results regardless of user config,
  # while _pick() correctly used $SEARCH_RESULTS. Now consistent.
  local _txt_n="${SEARCH_RESULTS:-5}"
  (( _txt_n > 5 )) && _txt_n=5  # cap at 5 for bg-job perf: we only use top result

  if [ -f "$key" ] && [ "$(_cache_age "$key")" -lt "$CACHE_TTL" ]; then
    results=$(cat "$key")
  else
    results=$("$YTDLP" "ytsearch${_txt_n}:$query" \
      --print "%(title)s | %(duration_string)s | %(webpage_url)s" \
      --no-download --no-warnings 2>/dev/null)
    # FIX #5 applied here too: validate before caching
    local valid_count; valid_count=$(echo "$results" | grep -cE 'https?://' 2>/dev/null || echo 0)
    [[ -n "$results" ]] && (( valid_count >= 1 )) && echo "$results" > "$key"
  fi

  [ -z "$results" ] && return 1
  url=$(echo "$results" | head -1 | awk -F ' \| ' '{print $NF}')
  echo "$url"
}

# v4-E â€” _txt_kill_bg_job now bumps the generation counter before killing.
# The old sentinel was a PID file: if m stop then m txt ran quickly, the old
# bg subshell could exit (seeing file gone) while the new one hadn't written yet.
# Now: each spawn gets a unique generation number. The bg job checks its own
# generation matches the current one â€” generation mismatch = stale job exits.
_txt_kill_bg_job() {
  local bg_pid_file="$DATA_DIR/txt_bg_pid"
  if [ -f "$bg_pid_file" ]; then
    local old_pid; old_pid=$(cat "$bg_pid_file" 2>/dev/null)
    if [ -n "$old_pid" ]; then
      kill -TERM -- "-$old_pid" 2>/dev/null || kill -TERM "$old_pid" 2>/dev/null
      sleep 0.2
      kill -0 "$old_pid" 2>/dev/null && kill -KILL "$old_pid" 2>/dev/null
    fi
    rm -f "$bg_pid_file"
  fi
  # Bump generation counter â€” any in-flight bg job will see a mismatch and exit
  local cur_gen=0
  [ -f "$TXT_BG_GEN_FILE" ] && cur_gen=$(cat "$TXT_BG_GEN_FILE" 2>/dev/null || echo 0)
  echo $(( cur_gen + 1 )) > "$TXT_BG_GEN_FILE"
}

do_txt() {
  local arg="${1:-}"
  local chosen_file=""

  if [ -z "$arg" ]; then
    local files=("$TXTS_DIR"/*.txt(N))
    if [ ${#files[@]} -eq 0 ]; then
      _warn "no .txt files in $TXTS_DIR"
      _info "create one and drop it there â€” one song name per line"
      return
    fi
    local display=()
    for f in "${files[@]}"; do
      local n; n=$(grep -cvE '^\s*(#|$)' "$f" 2>/dev/null || echo 0)
      display+=("$(basename "$f" .txt)  (${n} songs)")
    done
    local picked
    picked=$(printf '%s\n' "${display[@]}" | "$FZF" \
      --height 50% --reverse \
      --prompt "ğŸ“„ txt playlist > " \
      --header "ENTER to load Â· ESC cancel")
    [ -z "$picked" ] && { _warn "cancelled"; return; }
    local fname; fname=$(echo "$picked" | awk '{print $1}')
    chosen_file="$TXTS_DIR/${fname}.txt"
  else
    chosen_file=$(_txt_resolve "$arg")
    [ -z "$chosen_file" ] && { _err "txt file not found: $arg  (looked in $TXTS_DIR)"; return 1; }
  fi

  _txt_read_lines "$chosen_file"
  [ ${#TXT_LINES[@]} -eq 0 ] && { _err "txt file is empty or has only comments: $chosen_file"; return 1; }

  _start

  local fname_display; fname_display=$(basename "$chosen_file" .txt)
  _info "loading txt playlist: ${fname_display}  (${#TXT_LINES[@]} songs)"

  _txt_kill_bg_job  # kills old job AND bumps generation counter (v4-E)

  _txt_state_write "$chosen_file" 0

  _silent '{"command":["playlist-clear"]}'

  # zsh arrays are 1-based: TXT_LINES[1] is the first element
  local first_url
  first_url=$(_txt_search_and_play_line "${TXT_LINES[1]}")
  if [ -z "$first_url" ]; then
    _warn "could not find: ${TXT_LINES[1]} â€” skipping"
  else
    _ipc_loadfile "$first_url" "replace"
  fi

  # FIX #13 â€” capture critical paths at spawn time (not inherited)
  local _bg_socat="$SOCAT"
  local _bg_socket="$SOCKET"
  local _bg_jq="$JQ"
  local _bg_ytdlp="$YTDLP"
  local _bg_cache_dir="$CACHE_DIR"
  local _bg_cache_ttl="$CACHE_TTL"
  local _bg_search_n="${SEARCH_RESULTS:-5}"
  (( _bg_search_n > 5 )) && _bg_search_n=5

  # v4-E â€” capture current generation at spawn time.
  # If _txt_kill_bg_job runs and bumps the counter, this subshell will see
  # a mismatch on the next iteration and self-terminate cleanly.
  local _bg_gen; _bg_gen=$(cat "$TXT_BG_GEN_FILE" 2>/dev/null || echo 0)
  local _bg_gen_file="$TXT_BG_GEN_FILE"

  (
    local i=2
    local socat="$_bg_socat" socket="$_bg_socket" jq="$_bg_jq"
    local ytdlp="$_bg_ytdlp" cache_dir="$_bg_cache_dir" cache_ttl="$_bg_cache_ttl"
    local my_gen="$_bg_gen" gen_file="$_bg_gen_file"
    local search_n="$_bg_search_n"
    local _user_for_cache="${USER:-$(id -un)}"

    while [ $i -le ${#TXT_LINES[@]} ]; do
      # v4-E: Check generation â€” exit if superseded by a newer bg job
      local cur_gen; cur_gen=$(cat "$gen_file" 2>/dev/null || echo 0)
      [ "$cur_gen" = "$my_gen" ] || exit 0

      local url results key query
      query="${TXT_LINES[$i]}"
      # v4-T: include user in cache key (matches _cache_key helper)
      key="${cache_dir}/$(printf '%s\0%s' "$_user_for_cache" "$query" \
        | md5sum 2>/dev/null | cut -c1-32 \
        || printf '%s\0%s' "$_user_for_cache" "$query" | md5 2>/dev/null | cut -c1-32 \
        || printf '%s' "$query" | md5sum 2>/dev/null | cut -c1-32).cache"

      if [ -f "$key" ] && [ $(( $(date +%s) - $(stat -c%Y "$key" 2>/dev/null || stat -f%m "$key" 2>/dev/null || echo 0) )) -lt "$cache_ttl" ]; then
        results=$(cat "$key")
      else
        results=$("$ytdlp" "ytsearch${search_n}:${query}" \
          --print "%(title)s | %(duration_string)s | %(webpage_url)s" \
          --no-download --no-warnings 2>/dev/null)
        local vc; vc=$(echo "$results" | grep -cE 'https?://' 2>/dev/null || echo 0)
        [[ -n "$results" ]] && (( vc >= 1 )) && echo "$results" > "$key"
      fi

      if [ -n "$results" ]; then
        url=$(echo "$results" | head -1 | awk -F ' \| ' '{print $NF}')
        if [ -n "$url" ]; then
          local json
          json=$("$jq" -cn --arg url "$url" '{"command":["loadfile",$url,"append"]}')
          echo "$json" | "$socat" - "$socket" >/dev/null 2>&1
        fi
      fi
      i=$(( i + 1 ))
    done
  ) &
  local bg_pid=$!
  echo $bg_pid > "$DATA_DIR/txt_bg_pid"
  disown $bg_pid

  local title; title=$(_wait_prop media-title 30)
  _ok "â–¶  ${title:-${TXT_LINES[1]}}"
  _info "use: m txtnext (tn) / m txtprev (tp) to step through"
}

do_txtnext() {
  _need
  _txt_state_read
  [ -z "$TXT_ACTIVE_FILE" ] && { _err "no active txt playlist â€” start one with: m txt"; return 1; }

  _txt_read_lines "$TXT_ACTIVE_FILE"
  local total=${#TXT_LINES[@]}
  local next_idx=$(( TXT_ACTIVE_IDX + 1 ))

  if [ $next_idx -ge $total ]; then
    _warn "end of txt playlist: $(basename "$TXT_ACTIVE_FILE" .txt)  ($total songs)"
    return
  fi

  _txt_kill_bg_job
  _txt_state_write "$TXT_ACTIVE_FILE" "$next_idx"
  # zsh 1-based: element at position next_idx (0-based logical) = TXT_LINES[next_idx+1]
  local query="${TXT_LINES[$(( next_idx + 1 ))]}"
  _info "searching: ${query}"

  local url; url=$(_txt_search_and_play_line "$query")
  [ -z "$url" ] && { _warn "could not find: $query"; return; }

  _silent '{"command":["playlist-clear"]}'
  _ipc_loadfile "$url" "replace"
  local title; title=$(_wait_prop media-title 20)
  _ok "â­  [$(( next_idx + 1 ))/${total}]  ${title:-$query}"
}

do_txtprev() {
  _need
  _txt_state_read
  [ -z "$TXT_ACTIVE_FILE" ] && { _err "no active txt playlist â€” start one with: m txt"; return 1; }

  _txt_read_lines "$TXT_ACTIVE_FILE"
  local total=${#TXT_LINES[@]}
  local prev_idx=$(( TXT_ACTIVE_IDX - 1 ))

  if [ $prev_idx -lt 0 ]; then
    _warn "already at start of txt playlist: $(basename "$TXT_ACTIVE_FILE" .txt)"
    return
  fi

  _txt_kill_bg_job
  _txt_state_write "$TXT_ACTIVE_FILE" "$prev_idx"
  local query="${TXT_LINES[$(( prev_idx + 1 ))]}"
  _info "searching: ${query}"

  local url; url=$(_txt_search_and_play_line "$query")
  [ -z "$url" ] && { _warn "could not find: $query"; return; }

  _silent '{"command":["playlist-clear"]}'
  _ipc_loadfile "$url" "replace"
  local title; title=$(_wait_prop media-title 20)
  _ok "â®  [$(( prev_idx + 1 ))/${total}]  ${title:-$query}"
}

do_txtnow() {
  _txt_state_read
  if [ -z "$TXT_ACTIVE_FILE" ]; then
    _warn "no active txt playlist"
    _info "start one with: m txt"
    return
  fi
  _txt_read_lines "$TXT_ACTIVE_FILE"
  local total=${#TXT_LINES[@]}
  local current_query="${TXT_LINES[$(( TXT_ACTIVE_IDX + 1 ))]}"
  echo ""
  echo "  ${C}txt playlist:${X}  $(basename "$TXT_ACTIVE_FILE" .txt)"
  echo "  ${W}position:${X}    $(( TXT_ACTIVE_IDX + 1 )) / ${total}"
  echo "  ${W}current:${X}     ${current_query}"
  echo ""
  local ctx_start=$(( TXT_ACTIVE_IDX - 2 ))
  local ctx_end=$(( TXT_ACTIVE_IDX + 3 ))
  (( ctx_start < 0 )) && ctx_start=0
  (( ctx_end > total - 1 )) && ctx_end=$(( total - 1 ))
  local i=$ctx_start
  while [ $i -le $ctx_end ]; do
    local line="${TXT_LINES[$(( i + 1 ))]}"
    if [ $i -eq $TXT_ACTIVE_IDX ]; then
      printf "  ${G}â–¶ %d. %s${X}\n" "$(( i + 1 ))" "$line"
    else
      printf "    %d. %s\n" "$(( i + 1 ))" "$line"
    fi
    i=$(( i + 1 ))
  done
  echo ""
}

# FIX #18 â€” do_txts marker display fixed: use printf for color codes
do_txts() {
  echo ""
  printf "  ${C}txt playlists  â†’  %s${X}\n" "$TXTS_DIR"
  echo ""
  local found=0
  _txt_state_read
  for f in "$TXTS_DIR"/*.txt(N); do
    local name; name=$(basename "$f" .txt)
    local count; count=$(grep -cvE '^\s*(#|$)' "$f" 2>/dev/null || echo 0)
    if [ "$f" = "$TXT_ACTIVE_FILE" ]; then
      printf "  ${G}â–¶${X} ${W}%s${X}  (%s songs)  ${C}â†’ m txt %s${X}\n" "$name" "$count" "$name"
    else
      printf "  âˆ™ ${W}%s${X}  (%s songs)  ${C}â†’ m txt %s${X}\n" "$name" "$count" "$name"
    fi
    found=1
  done
  if [ $found -eq 0 ]; then
    echo "  (none yet)"
    echo ""
    printf "  ${Y}How to add:${X} drop a .txt file into %s\n" "$TXTS_DIR"
    echo "  One song name per line. Lines starting with # are comments."
  fi
  echo ""
}

do_txtpick() {
  _need
  _txt_state_read
  [ -z "$TXT_ACTIVE_FILE" ] && { _err "no active txt playlist â€” start one with: m txt"; return 1; }

  _txt_read_lines "$TXT_ACTIVE_FILE"
  local total=${#TXT_LINES[@]}

  local display=()
  local i=0
  while [ $i -lt $total ]; do
    local marker="  "; [ $i -eq $TXT_ACTIVE_IDX ] && marker="â–¶ "
    display+=("${marker}$(( i + 1 )). ${TXT_LINES[$(( i + 1 ))]}")
    i=$(( i + 1 ))
  done

  local chosen
  chosen=$(printf '%s\n' "${display[@]}" | "$FZF" \
    --height 60% --reverse \
    --prompt "ğŸ“„ jump to > " \
    --header "â–¶ = current Â· ENTER to play Â· ESC cancel" \
    --no-sort)
  [ -z "$chosen" ] && { _warn "cancelled"; return; }

  local num; num=$(echo "$chosen" | grep -oE '[0-9]+\.' | head -1 | tr -d '.')
  [ -z "$num" ] && { _err "could not parse selection"; return 1; }
  local new_idx=$(( num - 1 ))
  local query="${TXT_LINES[$num]}"

  _info "searching: ${query}"
  local url; url=$(_txt_search_and_play_line "$query")
  [ -z "$url" ] && { _warn "could not find: $query"; return; }

  _txt_state_write "$TXT_ACTIVE_FILE" "$new_idx"
  _txt_kill_bg_job

  _silent '{"command":["playlist-clear"]}'
  _ipc_loadfile "$url" "replace"
  local title; title=$(_wait_prop media-title 20)
  local total_n; total_n=${#TXT_LINES[@]}
  _ok "â–¶  [${num}/${total_n}]  ${title:-$query}"
}

do_txtedit() {
  local arg="${1:-}"
  local f
  if [ -z "$arg" ]; then
    local files=("$TXTS_DIR"/*.txt(N))
    [ ${#files[@]} -eq 0 ] && { _err "no txt files in $TXTS_DIR"; return 1; }
    local picked
    picked=$(printf '%s\n' "${files[@]}" | xargs -I{} basename {} .txt | "$FZF" \
      --height 40% --reverse --prompt "âœ  edit > " --header "pick file to edit")
    [ -z "$picked" ] && { _warn "cancelled"; return; }
    f="$TXTS_DIR/${picked}.txt"
  else
    f=$(_txt_resolve "$arg")
    if [ -z "$f" ]; then
      f="$TXTS_DIR/${arg}.txt"
      _info "creating new txt playlist: $arg"
      printf '# %s\n# one song name per line, blank lines and # lines are ignored\n\n' "$arg" > "$f"
    fi
  fi
  local editor="${EDITOR:-nano}"
  "$editor" "$f"
  local count; count=$(grep -cvE '^\s*(#|$)' "$f" 2>/dev/null || echo 0)
  _ok "saved: $(basename "$f")  (${count} songs)"
}

# â”€â”€ FIX #24 â€” txt-export: promote active txt playlist â†’ m3u â”€â”€

do_txt_export() {
  _txt_state_read
  [ -z "$TXT_ACTIVE_FILE" ] && { _err "no active txt playlist â€” start one with: m txt"; return 1; }

  local name; name=$(basename "$TXT_ACTIVE_FILE" .txt)
  local out="$PLAYLIST_DIR/${name}.m3u"
  _txt_read_lines "$TXT_ACTIVE_FILE"
  [ ${#TXT_LINES[@]} -eq 0 ] && { _err "txt file is empty"; return 1; }

  _info "resolving ${#TXT_LINES[@]} songs to URLs (this may take a while)..."
  local tmpf; tmpf=$(mktemp "$PLAYLIST_DIR/${name}.XXXXXX")
  local count=0 i=1
  while [ $i -le ${#TXT_LINES[@]} ]; do
    local url; url=$(_txt_search_and_play_line "${TXT_LINES[$i]}")
    if [ -n "$url" ]; then
      echo "$url" >> "$tmpf"
      count=$(( count + 1 ))
      printf '\r\e[2K  ${C}â†’${X} resolved %d/%d...' "$count" "${#TXT_LINES[@]}" >&2
    else
      _warn "skipped (not found): ${TXT_LINES[$i]}"
    fi
    i=$(( i + 1 ))
  done
  printf '\r\e[2K' >&2

  if [[ $count -eq 0 ]]; then
    rm -f "$tmpf"
    _err "could not resolve any tracks"
    return 1
  fi
  mv "$tmpf" "$out"
  _ok "exported '${name}' txt â†’ m3u  (${count} tracks)  â†’  m load ${name}"
}

# â”€â”€ FIX #25 â€” sleep timer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

_sleep_timer_cancel() {
  local timer_file="$DATA_DIR/sleep_timer_pid"
  if [[ -f "$timer_file" ]]; then
    local tpid; tpid=$(cat "$timer_file" 2>/dev/null)
    [[ -n "$tpid" ]] && kill "$tpid" 2>/dev/null
    rm -f "$timer_file"
  fi
}

do_sleep() {
  _need
  if [[ "${1:-}" == "cancel" || "${1:-}" == "off" ]]; then
    _sleep_timer_cancel
    _ok "sleep timer cancelled"
    return
  fi

  [[ -z "${1:-}" ]] && { _err "usage: m sleep <minutes> | cancel"; return 1; }
  [[ "${1:-}" =~ ^[0-9]+$ ]] || { _err "usage: m sleep <minutes>  (integer)"; return 1; }
  local mins="$1"
  local secs=$(( mins * 60 ))

  _sleep_timer_cancel  # Cancel any existing timer

  local timer_file="$DATA_DIR/sleep_timer_pid"
  (
    sleep "$secs"
    # Graceful: pause first, then stop
    echo '{"command":["set_property","pause",true]}' | "$SOCAT" - "$SOCKET" >/dev/null 2>&1
    sleep 2
    # Use the same stop logic
    if [[ -f "$MPV_PID_FILE" ]]; then
      local pid; pid=$(cat "$MPV_PID_FILE" 2>/dev/null)
      [[ -n "$pid" ]] && kill "$pid" 2>/dev/null
    fi
    rm -f "$timer_file"
  ) &
  local tpid=$!
  echo $tpid > "$timer_file"
  disown $tpid
  _ok "â²  sleep timer set: ${mins} minute(s)  (m sleep cancel to abort)"
}

# â”€â”€ v4-F + v4-Q â€” equalizer presets (structured af, no sed surgery) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#
# v4-Q: _EQ_NONE removed â€” it was unused dead code with an incorrect value.
#   ("lavfi=[aformat...]" is NOT flat; it inserts a lavfi node. Setting af=""
#   is the correct way to clear all filters, as do_eq flat already does.)
#
# v4-F: EQ filter strings are now applied via jq-built JSON to prevent shell
# interpolation issues with special characters in filter expressions.
# do_norm no longer uses sed surgery on the af string â€” it reads the current
# af value as JSON, manipulates the filter list structurally, then sets it back.
# This prevents corruption when EQ + norm are combined.

_EQ_BASS="lavfi=[equalizer=f=80:t=h:w=200:g=6,equalizer=f=40:t=h:w=80:g=4]"
_EQ_TREBLE="lavfi=[equalizer=f=8000:t=h:w=4000:g=5,equalizer=f=16000:t=h:w=4000:g=3]"
_EQ_VOCAL="lavfi=[equalizer=f=300:t=h:w=200:g=-2,equalizer=f=3000:t=h:w=2000:g=4]"
_EQ_LOUD="lavfi=[equalizer=f=60:t=h:w=120:g=5,equalizer=f=12000:t=h:w=6000:g=4,equalizer=f=1000:t=h:w=1000:g=-1]"

# _af_set <filter_string>: safely set af property via jq-built JSON
_af_set() {
  local filter="$1"
  local json; json=$("$JQ" -cn --arg af "$filter" '{"command":["set_property","af",$af]}')
  _silent_retry "$json"
}

# _af_get_raw: get current af as plain string (empty string if unset)
_af_get_raw() {
  local raw; raw=$(_cmd '{"command":["get_property","af"]}' 2>/dev/null)
  # mpv returns af as a string or null; extract safely
  echo "$raw" | "$JQ" -r '.data // ""' 2>/dev/null
}

# _af_has_filter <filter_fragment>: returns 0 if fragment appears in current af
_af_has_filter() {
  local current; current=$(_af_get_raw)
  echo "$current" | grep -qF "$1"
}

# _af_remove_filter <filter_fragment>: remove a named filter segment from af chain.
# Handles: "filter", "filter,next", "prev,filter", "prev,filter,next"
# This is structural: splits on comma, removes matching segment, rejoins.
_af_remove_filter() {
  local fragment="$1"
  local current; current=$(_af_get_raw)
  [ -z "$current" ] && return
  # Remove matching comma-delimited segments containing the fragment
  local new_af; new_af=$(echo "$current" \
    | awk -v frag="$fragment" 'BEGIN{FS=OFS=","} {
        result=""
        for(i=1;i<=NF;i++) {
          if(index($i, frag)==0) result=(result==""?$i:result","$i)
        }
        print result
      }')
  _af_set "$new_af"
}

do_eq() {
  _need
  local preset="${1:-}"
  case "$preset" in
    flat|off|none)
      # v4-F: clear only EQ filters, preserve norm if active
      local current; current=$(_af_get_raw)
      local new_af
      if echo "$current" | grep -qF "loudnorm"; then
        # Keep norm, remove EQ filters
        new_af=$(echo "$current" | awk -v frag="equalizer" 'BEGIN{FS=OFS=","}{
          result=""
          for(i=1;i<=NF;i++){if(index($i,frag)==0) result=(result==""?$i:result","$i)}
          print result
        }')
        # Also remove lavfi wrapper if it only contained EQ
        new_af=$(echo "$new_af" | sed 's/lavfi=\[,/lavfi=[/g; s/,\]/]/g; s/lavfi=\[\]//g')
        _af_set "${new_af:-}"
      else
        _af_set ""
      fi
      _ok "ğŸš  equalizer: flat (off)"
      ;;
    bass)   _af_set "$_EQ_BASS";   _ok "ğŸš  equalizer: bass boost" ;;
    treble) _af_set "$_EQ_TREBLE"; _ok "ğŸš  equalizer: treble boost" ;;
    vocal)  _af_set "$_EQ_VOCAL";  _ok "ğŸš  equalizer: vocal" ;;
    loud|loudness) _af_set "$_EQ_LOUD"; _ok "ğŸš  equalizer: loudness" ;;
    '')
      local cur; cur=$(_af_get_raw)
      _info "current af filter: ${cur:-flat/off}"
      echo ""
      echo "  presets: flat  bass  treble  vocal  loud"
      echo "  usage:   m eq <preset>"
      echo ""
      echo "  ${Y}note: m norm and m eq share the af chain â€” use m eq flat to clear EQ${X}"
      echo "  ${Y}      without disabling norm. Use m norm to toggle norm independently.${X}"
      ;;
    *)
      _err "unknown preset: $preset  (flat | bass | treble | vocal | loud)"
      return 1
      ;;
  esac
}

# â”€â”€ v4-F â€” loudness normalisation toggle (structural af manipulation) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

do_norm() {
  _need
  local current; current=$(_af_get_raw)

  if echo "$current" | grep -qF "loudnorm"; then
    # Toggle OFF â€” remove acompressor and loudnorm segments structurally
    # Handles chains like: "lavfi=[eq],acompressor,loudnorm" correctly
    local new_af; new_af=$(echo "$current" | awk 'BEGIN{FS=OFS=","}{
      result=""
      for(i=1;i<=NF;i++){
        if(index($i,"acompressor")==0 && index($i,"loudnorm")==0)
          result=(result==""?$i:result","$i)
      }
      print result
    }')
    _af_set "${new_af:-}"
    _ok "ğŸ”‡ loudness normalisation: OFF"
  else
    # Toggle ON â€” append to existing chain (preserves EQ filters)
    local new_af="${current:+${current},}acompressor,loudnorm"
    _af_set "$new_af"
    _ok "ğŸ”Š loudness normalisation: ON  (levels balanced across tracks)"
  fi
}

# â”€â”€ v4-N â€” play similar: Last.fm API when available; honest fallback â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# v4-N: The old implementation just did YouTube search for "music similar to X"
# which YouTube's algorithm does not understand semantically â€” misleading UX.
# Now: if LASTFM_API_KEY is configured, we call Last.fm's similar tracks API
# and get a real recommendation. Otherwise, we label the YouTube fallback
# accurately so the user knows exactly what they're getting.

do_similar() {
  _need
  [ -s "$HISTORY_FILE" ] || { _warn "no history yet â€” play some tracks first"; return; }

  local seeds
  seeds=$(_tac "$HISTORY_FILE" | awk -F'\t' '!seen[$2]++ {print $2}' | head -3)
  [ -z "$seeds" ] && { _warn "not enough history"; return; }

  local seed_title; seed_title=$(echo "$seeds" | head -1)

  # Try Last.fm API for real semantic similarity
  if [[ -n "${LASTFM_API_KEY:-}" ]] && command -v curl >/dev/null 2>&1; then
    _info "querying Last.fm for tracks similar to: ${seed_title}"

    # Extract artist from title (best-effort: "Artist - Title" or just title)
    local artist track
    if echo "$seed_title" | grep -q ' - '; then
      artist=$(echo "$seed_title" | cut -d'-' -f1 | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
      track=$(echo "$seed_title"  | cut -d'-' -f2- | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
    else
      artist=""; track="$seed_title"
    fi

    local lastfm_resp
    lastfm_resp=$(curl -s --max-time 8 \
      "https://ws.audioscrobbler.com/2.0/?method=track.getsimilar&artist=$(python3 -c "import urllib.parse,sys; print(urllib.parse.quote(sys.argv[1]))" "$artist" 2>/dev/null || echo "$artist")&track=$(python3 -c "import urllib.parse,sys; print(urllib.parse.quote(sys.argv[1]))" "$track" 2>/dev/null || echo "$track")&api_key=${LASTFM_API_KEY}&format=json&limit=10" 2>/dev/null)

    local similar_title
    similar_title=$(echo "$lastfm_resp" | "$JQ" -r \
      '.similartracks.track[] | "\(.artist.name) - \(.name)"' 2>/dev/null \
      | grep -v "^null" | head -5 \
      | awk 'BEGIN{srand()} {a[NR]=$0} END{if(NR>0) print a[int(rand()*NR)+1]}')

    if [[ -n "$similar_title" ]]; then
      _info "Last.fm recommends: ${similar_title}"
      local url; url=$(_pick "$similar_title") || return 1
      [ -z "$url" ] && { _warn "cancelled"; return; }
      _ipc_loadfile "$url" "append-play"
      _ok "â• added Last.fm similar track: ${similar_title}"
      _queue_snapshot
      return
    fi
    _warn "Last.fm returned no similar tracks â€” falling back to YouTube search"
  fi

  # Honest fallback: label it clearly as a YouTube keyword search, not semantic
  _info "YouTube keyword search for: ${seed_title}  (set LASTFM_API_KEY in config for real recommendations)"
  local combined_query="${seed_title}"
  local url; url=$(_pick "$combined_query") || return 1
  [ -z "$url" ] && { _warn "cancelled"; return; }
  _ipc_loadfile "$url" "append-play"
  _ok "â• added to queue (YouTube keyword match â€” not semantic similarity)"
  _queue_snapshot
}

# â”€â”€ FIX #32 â€” export likes / history to CSV â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

do_export() {
  local target="${1:-likes}"
  local file
  case "$target" in
    likes)   file="$LIKES_FILE" ;;
    history) file="$HISTORY_FILE" ;;
    *) _err "usage: m export [likes|history]"; return 1 ;;
  esac

  [ -s "$file" ] || { _warn "no data to export in: $target"; return; }

  echo "date,title,url"
  awk -F'\t' '{
    # Escape double-quotes in fields by doubling them (CSV standard)
    gsub(/"/, "\"\"", $1); gsub(/"/, "\"\"", $2); gsub(/"/, "\"\"", $3)
    printf "\"%s\",\"%s\",\"%s\"\n", $1, $2, $3
  }' "$file"
}

# â”€â”€ v4-M â€” m doctor: full system diagnostics â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

do_doctor() {
  echo ""
  echo "  ${C}m doctor â€” system diagnostics${X}"
  echo "  $(date)"
  echo ""

  # 1. Binary versions
  echo "  ${W}Dependencies:${X}"
  for bin_var in YTDLP MPV FZF SOCAT JQ; do
    local bin_path="${(P)bin_var}"
    if [[ -n "$bin_path" && -x "$bin_path" ]]; then
      local ver=""
      case "$bin_var" in
        YTDLP)  ver=$("$bin_path" --version 2>/dev/null | head -1) ;;
        MPV)    ver=$("$bin_path" --version 2>/dev/null | head -1 | awk '{print $1,$2,$3}') ;;
        FZF)    ver=$("$bin_path" --version 2>/dev/null | head -1) ;;
        SOCAT)  ver=$("$bin_path" -V 2>&1 | head -1 | awk '{print $1,$2}') ;;
        JQ)     ver=$("$bin_path" --version 2>/dev/null | head -1) ;;
      esac
      printf "  ${G}âœ”${X}  %-8s  %s\n      path: %s\n" "$bin_var" "${ver:-unknown version}" "$bin_path"
    else
      printf "  ${R}âœ–${X}  %-8s  ${R}NOT FOUND${X}\n" "$bin_var"
    fi
    echo ""
  done

  # 2. IPC socket liveness
  echo "  ${W}Daemon:${X}"
  if [ ! -S "$SOCKET" ]; then
    printf "  ${R}âœ–${X}  socket: not present  (%s)\n" "$SOCKET"
  else
    printf "  ${G}âœ”${X}  socket: exists  (%s)\n" "$SOCKET"
    if echo '{"command":["get_version"]}' \
        | "$SOCAT" -t 2 - "$SOCKET" >/dev/null 2>&1; then
      local mpv_ipc_ver; mpv_ipc_ver=$(echo '{"command":["get_version"]}' \
        | "$SOCAT" -t 2 - "$SOCKET" 2>/dev/null | "$JQ" -r '.data // "?"' 2>/dev/null)
      printf "  ${G}âœ”${X}  IPC: responsive  (mpv IPC version: %s)\n" "$mpv_ipc_ver"
      local title; title=$(_get media-title 2>/dev/null)
      if [[ -n "$title" ]]; then
        local paused; paused=$(_get pause 2>/dev/null)
        local vol; vol=$(_get volume 2>/dev/null | awk '{printf "%.0f",$1}')
        local pl_count; pl_count=$(_cmd '{"command":["get_property","playlist"]}' \
          | "$JQ" '.data|length' 2>/dev/null)
        printf "  ${G}âœ”${X}  now playing: %s  (paused=%s  vol=%s%%  queue=%s)\n" \
          "$title" "$paused" "$vol" "${pl_count:-?}"
      else
        printf "  ${C}â†’${X}  idle (no track loaded)\n"
      fi
    else
      printf "  ${R}âœ–${X}  IPC: socket exists but mpv is unresponsive â€” run: m stop && m start\n"
    fi
  fi
  echo ""

  # 3. Stale lock check
  echo "  ${W}Lock files:${X}"
  if [ -d "$LOCK_FILE_D" ]; then
    local lock_pid; lock_pid=$(cat "$LOCK_FILE" 2>/dev/null || echo "")
    if [[ -n "$lock_pid" ]] && kill -0 "$lock_pid" 2>/dev/null; then
      printf "  ${Y}âš ${X}  start.lock held by PID %s (live process)\n" "$lock_pid"
    else
      printf "  ${R}âœ–${X}  start.lock STALE (PID %s is dead) â€” run: m stop to clean up\n" "${lock_pid:-unknown}"
    fi
  else
    printf "  ${G}âœ”${X}  no stale locks\n"
  fi
  echo ""

  # 4. Data files
  echo "  ${W}Data files:${X}"
  local history_lines=0 likes_lines=0
  [ -f "$HISTORY_FILE" ] && history_lines=$(wc -l < "$HISTORY_FILE" | tr -d ' ')
  [ -f "$LIKES_FILE"   ] && likes_lines=$(wc -l < "$LIKES_FILE"   | tr -d ' ')
  printf "  history:  %s entries  (%s)\n" "$history_lines" "$HISTORY_FILE"
  printf "  likes:    %s entries  (%s)\n" "$likes_lines" "$LIKES_FILE"
  if [ -f "$QUEUE_SNAPSHOT" ]; then
    local snap_count; snap_count=$(grep -c . "$QUEUE_SNAPSHOT" 2>/dev/null || echo 0)
    printf "  snapshot: %s tracks  (restore with: m queue-restore)\n" "$snap_count"
  else
    printf "  snapshot: none\n"
  fi
  echo ""

  # 5. Cache stats
  echo "  ${W}Cache:${X}"
  local cache_total=0 cache_expired=0
  for f in "$CACHE_DIR"/*.cache(N); do
    cache_total=$(( cache_total + 1 ))
    [ "$(_cache_age "$f")" -ge "$CACHE_TTL" ] && cache_expired=$(( cache_expired + 1 ))
  done
  printf "  %s total  |  %s fresh  |  %s expired  |  TTL: %ss\n" \
    "$cache_total" "$(( cache_total - cache_expired ))" "$cache_expired" "$CACHE_TTL"
  echo ""

  # 6. Config
  echo "  ${W}Config:${X}"
  printf "  MUSIC_ROOT=%s\n  SEARCH_RESULTS=%s  CACHE_TTL=%ss  HISTORY_MAX=%s\n" \
    "$MUSIC_ROOT" "$SEARCH_RESULTS" "$CACHE_TTL" "$HISTORY_MAX"
  printf "  LASTFM_API_KEY=%s\n  SCROBBLE_URL=%s\n" \
    "${LASTFM_API_KEY:+(set)}" "${SCROBBLE_URL:+(set)}"
  echo ""
}



do_update() {
  _info "updating yt-dlp..."
  local old_ver; old_ver=$("$YTDLP" --version 2>/dev/null | head -1)

  local rc=0
  if [[ "$OS" == "mac" ]]; then
    if command -v brew >/dev/null 2>&1; then
      brew upgrade yt-dlp 2>&1 || rc=$?
    else
      "$YTDLP" -U 2>&1 || rc=$?
    fi
  else
    if command -v pip3 >/dev/null 2>&1; then
      pip3 install -U yt-dlp 2>&1 || rc=$?
    elif command -v pip >/dev/null 2>&1; then
      pip install -U yt-dlp 2>&1 || rc=$?
    else
      "$YTDLP" -U 2>&1 || rc=$?
    fi
  fi

  if [[ $rc -ne 0 ]]; then
    _warn "update may have failed (exit $rc) â€” check output above"
  fi

  local new_ver; new_ver=$("$YTDLP" --version 2>/dev/null | head -1)
  if [[ "$old_ver" != "$new_ver" ]]; then
    _ok "yt-dlp updated: ${old_ver} â†’ ${new_ver}"
  else
    _ok "yt-dlp already up-to-date: ${new_ver}"
  fi

  # Also clear stale version check cache
  rm -f "$CACHE_DIR/.ytdlp_version_check"
}

# â”€â”€ m log â€” view mpv error log â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

do_log() {
  if [[ ! -s "$MPV_LOG" ]]; then
    _info "mpv log is empty: $MPV_LOG"
    return
  fi
  echo ""
  echo "  ${C}mpv log:${X}  $MPV_LOG"
  echo ""
  tail -50 "$MPV_LOG"
  echo ""
}

do_log_clear() {
  > "$MPV_LOG"
  _ok "mpv log cleared"
}

# â”€â”€ cache management â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

do_cache_clear() {
  local count; count=$(ls "$CACHE_DIR"/*.cache 2>/dev/null | wc -l | tr -d ' ')
  rm -f "$CACHE_DIR"/*.cache
  _ok "cleared ${count} cached search(es)"
}

do_cache_stats() {
  local total=0 expired=0 fresh=0
  for f in "$CACHE_DIR"/*.cache(N); do
    total=$(( total + 1 ))
    if [ "$(_cache_age "$f")" -ge "$CACHE_TTL" ]; then
      expired=$(( expired + 1 ))
    else
      fresh=$(( fresh + 1 ))
    fi
  done
  echo ""
  echo "  ${C}cache stats:${X}"
  echo "  total:   ${total}"
  echo "  fresh:   ${G}${fresh}${X}  (TTL: ${CACHE_TTL}s)"
  echo "  expired: ${Y}${expired}${X}  (auto-refreshed on next use)"
  echo "  dir:     $CACHE_DIR"
  echo ""
}

do_cache_prune() {
  local count=0
  for f in "$CACHE_DIR"/*.cache(N); do
    if [ "$(_cache_age "$f")" -ge "$CACHE_TTL" ]; then
      rm -f "$f"
      count=$(( count + 1 ))
    fi
  done
  _ok "pruned ${count} expired cache entrie(s)"
}

# â”€â”€ devices â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

do_devices() {
  echo ""
  echo "  ${C}audio devices:${X}"
  "$MPV" --audio-device=help 2>&1 | grep "'" | sed 's/^/  /'
  echo ""
  echo "  current:     ${W}$(_get audio-device)${X}"
  echo "  speakers:    ${W}${AUDIO_DEVICE_SPEAKERS:-not configured}${X}"
  echo "  headphones:  ${W}${AUDIO_DEVICE_HEADPHONES:-not configured}${X}"
  echo "  (set in: $CONFIG_FILE)"
  echo ""
}

# â”€â”€ help â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

do_help() {
  cat <<EOF

  ${C}m â€” terminal music CLI${X}   (v4 production)
  data: ~/music_system/   config: $CONFIG_FILE
  log:  $MPV_LOG

  ${W}PLAY${X}
    m "query"              search YouTube & play (fzf picker)
    m ~/path/to/file.mp3   play a local file directly
    m "query" -a           add to queue (dedup-guarded)
    m "query" -a -f        force-add (bypass dedup)
    m "query" -hp          play via headphones
    m "query" -sp          play via speakers
    m "query" -a -hp       add + switch to headphones

  ${W}TRANSPORT${X}
    pause / pp             toggle pause
    next  / mn             next track
    prev  / mb             previous track
    seek +30               seek forward 30s
    seek -15               seek back 15s
    seek 1:30              jump to 1m30s
    seek 90                jump to 90s
    speed 1.5              set playback speed (0.25â€“4.0)
    speed + / -            step speed up/down (true inverse)
    speed r                reset speed to 1x
    stop                   kill daemon (precise PID targeting)
    start                  start daemon

  ${W}VOLUME & OUTPUT${X}
    vol                    show current volume
    vol 80                 set volume (0-150)
    vol + / -              step Â±${VOLUME_STEP} (clamped 0-150)
    hp / headphones        switch to headphones
    sp / speakers          switch to speakers
    devices                list audio devices + show config

  ${W}AUDIO FILTERS${X}
    eq                     show current equalizer preset
    eq flat|bass|treble|vocal|loud   apply EQ preset (v4: safe with norm combined)
    norm                   toggle loudness normalisation (v4: structural af chain)

  ${W}INFO${X}
    now                    current track + position + queue pos
    bar / progress         live progress bar (spd + vol displayed)
                             keys: p=pause  n=next  b=prev
                                   ,=Ã¢ÂˆÂ’10s  .=+10s  +/Ã¢ÂˆÂ’=vol
                                   r=repeat  1=repeat-one  q=quit
    scrub / slider         interactive seek slider
    queue                  show queue
    status                 daemon status + queue count + txt state

  ${W}QUEUE MANAGEMENT${X}
    shuffle                shuffle queue
    repeat / rp            toggle repeat-playlist
    repeat-one / ro        toggle repeat-one (loop current track)
    clear                  clear queue
    qmove <from> <to>      move track in queue (1-based)
    qrm <pos>              remove track from queue (1-based)
    queue-restore / qr     restore queue from auto-snapshot (v4 crash recovery)

  ${W}LIKES${X}
    like                   Ã¢ÂÂ¤ like current track
    unlike                 remove a liked track (fzf)
    likes                  list liked tracks
    likes-play / lp        pick & play a liked track (fzf)
    love                   play random liked track (unbiased RNG)

  ${W}HISTORY${X}
    history                fuzzy-search & replay history (newest first)
    history-clear          wipe play history (with confirmation)
    similar                add similar track (Last.fm API if LASTFM_API_KEY set, else YouTube)

  ${W}TXT PLAYLISTS${X}
    txts                   list all txt files with song counts
    txt                    fzf-pick a txt file and start playing
    txt <n>             load a specific txt file
    txtnext / tn           next song in active txt playlist
    txtprev / tp           previous song in active txt playlist
    txtnow                 show active txt file + surrounding context
    txtpick / tj           fzf-jump to any song in active txt
    txtedit / te           fzf-pick a txt file to edit in \$EDITOR
    txtedit <n>         edit or create a named txt file
    txt-export             resolve active txt playlist Ã¢Â†Â’ saved m3u

  ${W}QUEUE PLAYLISTS${X}
    save <n>            save current queue as playlist
    load <n>            load playlist into queue (v4: O(1) dedup, not O(nÃ‚Â²))
    playlists / pls        list saved playlists
    pldel <n>           delete a playlist (with confirmation)

  ${W}DOWNLOAD & IMPORT${X}
    dl "query"             download as MP3 (v4: progress visible)
    dl-list                list downloaded files
    import "url"           import YouTube playlist (v4: overwrite confirmation)

  ${W}SLEEP TIMER${X}
    sleep <minutes>        stop playback after N minutes
    sleep cancel           cancel active sleep timer

  ${W}EXPORT${X}
    export likes           print likes as CSV (redirect to file)
    export history         print history as CSV

  ${W}UPDATES${X}
    update                 update yt-dlp to latest version

  ${W}LOGS & DIAGNOSTICS${X}
    doctor                 full system diagnostics: deps, IPC probe, locks, cache (v4)
    log                    show last 50 lines of mpv error log
    log-clear              clear mpv log

  ${W}CACHE${X}
    cache-clear            remove all search caches
    cache-prune            remove only expired caches (>TTL)
    cache-stats            show cache info (respects CACHE_TTL config)

EOF
}

# â”€â”€ main dispatch â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Run yt-dlp age check (once per day, non-blocking output)
_check_ytdlp_age

[ $# -eq 0 ] && { do_status; exit 0; }

case "$1" in
  pause|pp)            do_pause;                   exit 0 ;;
  next|mn)             do_next;                    exit 0 ;;
  prev|mb)             do_prev;                    exit 0 ;;
  stop)                do_stop;                    exit 0 ;;
  start)               do_start;                   exit 0 ;;
  shuffle)             do_shuffle;                 exit 0 ;;
  repeat|rp)           do_repeat;                  exit 0 ;;
  repeat-one|ro)       do_repeat_one;              exit 0 ;;
  clear)               do_clear;                   exit 0 ;;
  now)                 do_now;                     exit 0 ;;
  bar|progress)        do_bar;                     exit 0 ;;
  scrub|slider)        do_scrub;                   exit 0 ;;
  queue)               do_queue;                   exit 0 ;;
  qmove)               do_queue_move "$2" "$3";    exit 0 ;;
  qrm)                 do_queue_remove "$2";       exit 0 ;;
  status)              do_status;                  exit 0 ;;
  hp|headphones)       do_hp;                      exit 0 ;;
  sp|speakers)         do_sp;                      exit 0 ;;
  devices)             do_devices;                 exit 0 ;;
  playlists|pls)       do_playlists;               exit 0 ;;
  save)                do_save "${2:-}";           exit 0 ;;
  load)                do_load "${2:-}";           exit 0 ;;
  pldel)               do_playlist_del "${2:-}";   exit 0 ;;
  import)              do_import "${2:-}";         exit 0 ;;
  dl)                  do_dl "${2:-}";             exit 0 ;;
  dl-list)             do_dl_list;                 exit 0 ;;
  txt)                 do_txt "${2:-}";            exit 0 ;;
  txts)                do_txts;                    exit 0 ;;
  txtnext|tn)          do_txtnext;                 exit 0 ;;
  txtprev|tp)          do_txtprev;                 exit 0 ;;
  txtnow)              do_txtnow;                  exit 0 ;;
  txtpick|tj)          do_txtpick;                 exit 0 ;;
  txtedit|te)          do_txtedit "${2:-}";        exit 0 ;;
  txt-export)          do_txt_export;              exit 0 ;;
  vol|volume)          do_vol "${2:-}";            exit 0 ;;
  seek)                do_seek "${2:-}";           exit 0 ;;
  speed)               do_speed "${2:-}";          exit 0 ;;
  like)                do_like;                    exit 0 ;;
  unlike)              do_unlike;                  exit 0 ;;
  likes)               do_likes;                   exit 0 ;;
  likes-play|lp)       do_likes_play;              exit 0 ;;
  love)                do_love;                    exit 0 ;;
  similar)             do_similar;                 exit 0 ;;
  history|hist)        do_history;                 exit 0 ;;
  history-clear)       do_history_clear;           exit 0 ;;
  eq)                  do_eq "${2:-}";             exit 0 ;;
  norm)                do_norm;                    exit 0 ;;
  sleep)               do_sleep "${2:-}";          exit 0 ;;
  export)              do_export "${2:-}";         exit 0 ;;
  update)              do_update;                  exit 0 ;;
  doctor)              do_doctor;                  exit 0 ;;
  queue-restore|qr)    do_queue_restore;           exit 0 ;;
  log)                 do_log;                     exit 0 ;;
  log-clear)           do_log_clear;               exit 0 ;;
  cache-clear)         do_cache_clear;             exit 0 ;;
  cache-prune)         do_cache_prune;             exit 0 ;;
  cache-stats)         do_cache_stats;             exit 0 ;;
  help|-h|--help)      do_help;                    exit 0 ;;
esac

# â”€â”€ Free-form query with optional flags â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# FIX #35 â€” use array for QUERY_ARGS, not string concatenation
typeset -a QUERY_ARGS
QUERY_ARGS=()
FLAG_ADD=0
FLAG_FORCE=0
FLAG_HP=0
FLAG_SP=0

for arg in "$@"; do
  case "$arg" in
    -a|--add)          FLAG_ADD=1 ;;
    -f|--force)        FLAG_FORCE=1 ;;
    -hp|--headphones)  FLAG_HP=1 ;;
    -sp|--speakers)    FLAG_SP=1 ;;
    -*)                _die "unknown flag: $arg  (run: m help)" ;;
    *)                 QUERY_ARGS+=("$arg") ;;
  esac
done

[ ${#QUERY_ARGS[@]} -eq 0 ] && _die "no query â€” usage: m \"song name\"  or  m help"

# Join query args with spaces
QUERY="${(j: :)QUERY_ARGS}"

if [ $FLAG_ADD -eq 1 ]; then
  if [ $FLAG_FORCE -eq 1 ]; then
    do_add_force "$QUERY"
  else
    do_add "$QUERY"
  fi
else
  do_play "$QUERY"
fi

[ $FLAG_HP -eq 1 ] && sleep 0.4 && do_hp
[ $FLAG_SP -eq 1 ] && sleep 0.4 && do_sp
