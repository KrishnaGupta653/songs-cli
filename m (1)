#!/usr/bin/env zsh
# ============================================================
#  m â€” terminal music CLI  (production build)
#  All state lives in ~/music_system/
#
#  Structure:
#    ~/music_system/
#    â”œâ”€â”€ m                  â† this script (symlinked to /usr/local/bin/m)
#    â”œâ”€â”€ socket/            â† mpv IPC socket
#    â”œâ”€â”€ cache/             â† yt-dlp search caches (1hr TTL)
#    â”œâ”€â”€ playlists/         â† saved .m3u playlists
#    â”œâ”€â”€ data/
#    â”‚   â”œâ”€â”€ likes          â† liked tracks
#    â”‚   â””â”€â”€ history        â† play history (last 500)
#    â””â”€â”€ locks/             â† daemon start lockfile
# ============================================================

# â”€â”€ paths (everything inside music_system) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
MUSIC_ROOT="$HOME/music_system"
SOCKET_DIR="$MUSIC_ROOT/socket"
SOCKET="$SOCKET_DIR/mpv.sock"
CACHE_DIR="$MUSIC_ROOT/cache"
PLAYLIST_DIR="$MUSIC_ROOT/playlists"
DATA_DIR="$MUSIC_ROOT/data"
LOCK_DIR="$MUSIC_ROOT/locks"
LOCK_FILE="$LOCK_DIR/start.lock"
LIKES_FILE="$DATA_DIR/likes"
HISTORY_FILE="$DATA_DIR/history"

# â”€â”€ binary paths â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
YTDLP="/opt/homebrew/bin/yt-dlp"
MPV="/opt/homebrew/bin/mpv"
FZF="/opt/homebrew/bin/fzf"
SOCAT="/opt/homebrew/bin/socat"
JQ="/opt/homebrew/bin/jq"

# â”€â”€ colours â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
R=$'\e[0;31m'; G=$'\e[0;32m'; Y=$'\e[0;33m'
C=$'\e[0;36m'; W=$'\e[1;37m'; M=$'\e[0;35m'; X=$'\e[0m'

# â”€â”€ bootstrap dirs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
_bootstrap() {
  mkdir -p "$SOCKET_DIR" "$CACHE_DIR" "$PLAYLIST_DIR" "$DATA_DIR" "$LOCK_DIR"
  touch -a "$LIKES_FILE" "$HISTORY_FILE"
}
_bootstrap

# â”€â”€ logging helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
_err()  { echo "${R}âœ– $*${X}" >&2; exit 1 }
_ok()   { echo "${G}âœ” $*${X}" }
_info() { echo "${C}â†’ $*${X}" }
_warn() { echo "${Y}âš  $*${X}" }

# â”€â”€ dependency check â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
_check_deps() {
  local missing=0
  for bin in "$YTDLP" "$MPV" "$FZF" "$SOCAT" "$JQ"; do
    [ -x "$bin" ] || { _warn "missing: $bin"; missing=1 }
  done
  [ $missing -eq 1 ] && _err "install missing deps: brew install yt-dlp mpv fzf socat jq"
}

# â”€â”€ daemon management â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
_start() {
  [ -S "$SOCKET" ] && return 0

  # Lock to prevent race condition with concurrent m invocations
  if [ -f "$LOCK_FILE" ]; then
    local lock_age=$(( $(date +%s) - $(stat -f%m "$LOCK_FILE" 2>/dev/null || echo 0) ))
    if [ "$lock_age" -lt 8 ]; then
      # Another process is starting â€” wait for socket
      _info "waiting for daemon..."
      for i in $(seq 1 20); do
        sleep 0.3
        [ -S "$SOCKET" ] && return 0
      done
    fi
    rm -f "$LOCK_FILE"
  fi

  touch "$LOCK_FILE"
  _info "starting daemon..."

  "$MPV" --no-video --idle=yes \
    --input-ipc-server="$SOCKET" \
    --script-opts=ytdl_hook-ytdl_path="$YTDLP" \
    --audio-device=coreaudio/BuiltInSpeakerDevice \
    --volume=80 --quiet --really-quiet \
    --ytdl-format="bestaudio/best" \
    --cache=yes --cache-secs=60 \
    --demuxer-max-bytes=50MiB \
    --prefetch-playlist=yes &
  disown

  for i in $(seq 1 25); do
    sleep 0.3
    if [ -S "$SOCKET" ]; then
      rm -f "$LOCK_FILE"
      return 0
    fi
  done

  rm -f "$LOCK_FILE"
  _err "mpv daemon failed to start â€” check: $MPV --no-video --idle"
}

_need() {
  [ -S "$SOCKET" ] || _err "daemon not running â€” run: m start"
}

# â”€â”€ IPC helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
_cmd() {
  echo "$1" | "$SOCAT" - "$SOCKET" 2>/dev/null
}

_silent() {
  echo "$1" | "$SOCAT" - "$SOCKET" >/dev/null 2>&1
}

_get() {
  local raw
  raw=$(_cmd "{\"command\":[\"get_property\",\"$1\"]}")
  echo "$raw" | "$JQ" -r '.data // empty' 2>/dev/null
}

# Wait for a property to become non-empty (replaces blind sleeps)
_wait_prop() {
  local prop="$1" max="${2:-25}" val
  for i in $(seq 1 "$max"); do
    val=$(_get "$prop")
    [ -n "$val" ] && { echo "$val"; return 0 }
    sleep 0.15
  done
  echo ""
}

# â”€â”€ search & pick (with cache) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
_cache_key() {
  # md5 of query string â†’ cache filename
  echo "$1" | md5 | tr -d ' \n'
}

_cache_age() {
  local f="$1"
  [ -f "$f" ] || { echo 9999; return }
  echo $(( $(date +%s) - $(stat -f%m "$f" 2>/dev/null || echo 0) ))
}

_pick() {
  local query="$1"
  local key="$CACHE_DIR/$(_cache_key "$query").cache"
  local results

  if [ -f "$key" ] && [ "$(_cache_age "$key")" -lt 3600 ]; then
    # Cache hit â€” instant
    results=$(cat "$key")
  else
    # Cache miss â€” fetch + store
    _info "searching..."
    results=$("$YTDLP" "ytsearch20:$query" \
      --print "%(title)s | %(duration_string)s | %(webpage_url)s" \
      --no-download --no-warnings 2>/dev/null)
    [ -n "$results" ] && echo "$results" > "$key"
  fi

  [ -z "$results" ] && { _warn "no results for: $query"; return }

  echo "$results" | "$FZF" \
    --height 55% --reverse \
    --prompt "ğŸµ " \
    --header "ENTER select Â· ESC cancel Â· cached if instant" \
    --preview 'echo {} | sed "s/ | /\n/g"' \
    --preview-window=down:3:wrap \
    --ansi \
  | awk -F ' \| ' '{print $NF}'
}

# â”€â”€ history helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
_log_history() {
  local title="$1" url="$2"
  [ -z "$url" ] && return
  echo "$(date '+%Y-%m-%d %H:%M')\t${title}\t${url}" >> "$HISTORY_FILE"
  # Keep last 500 lines
  local lines; lines=$(wc -l < "$HISTORY_FILE" | tr -d ' ')
  if [ "$lines" -gt 500 ]; then
    tail -500 "$HISTORY_FILE" > "$HISTORY_FILE.tmp" && mv "$HISTORY_FILE.tmp" "$HISTORY_FILE"
  fi
}

# â”€â”€ extract clean YouTube URL (for saves / likes) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
_clean_url() {
  local url="$1"
  local vid
  vid=$(echo "$url" | grep -oE 'v=([A-Za-z0-9_-]+)' | head -1 | cut -d= -f2)
  [ -z "$vid" ] && vid=$(echo "$url" | grep -oE 'youtu\.be/([A-Za-z0-9_-]+)' | head -1 | sed 's|youtu.be/||')
  [ -n "$vid" ] && echo "https://www.youtube.com/watch?v=$vid" || echo "$url"
}

# â”€â”€ subcommands â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

do_play() {
  _start
  _silent '{"command":["playlist-clear"]}'
  local url; url=$(_pick "$1")
  [ -z "$url" ] && { _warn "cancelled"; return }
  _info "buffering..."
  _silent "{\"command\":[\"loadfile\",\"$url\",\"append-play\"]}"
  local title; title=$(_wait_prop media-title 30)
  _ok "â–¶  ${title:-unknown}"
  _log_history "${title:-unknown}" "$(_clean_url "$url")"
}

do_add() {
  _start
  local url; url=$(_pick "$1")
  [ -z "$url" ] && { _warn "cancelled"; return }
  _silent "{\"command\":[\"loadfile\",\"$url\",\"append-play\"]}"
  _ok "â• added to queue"
}

do_pause() {
  _need
  _silent '{"command":["cycle","pause"]}'
  local p; p=$(_get pause)
  [ "$p" = "true" ] && _info "â¸  paused" || _info "â–¶  resumed"
}

do_next() {
  _need
  _silent '{"command":["playlist-next"]}'
  local title; title=$(_wait_prop media-title 20)
  _ok "â­  ${title:-end of queue}"
}

do_prev() {
  _need
  _silent '{"command":["playlist-prev"]}'
  local title; title=$(_wait_prop media-title 20)
  _ok "â®  ${title:-beginning of queue}"
}

do_stop() {
  pkill -f "mpv.*$SOCKET" 2>/dev/null
  pkill -f "mpv.*mpvsocket" 2>/dev/null
  rm -f "$SOCKET" "$LOCK_FILE"
  _ok "stopped"
}

do_start() {
  _check_deps
  _start && _ok "daemon ready"
}

do_vol() {
  _need
  case "$1" in
    +)  _silent '{"command":["add","volume",5]}' ;;
    -)  _silent '{"command":["add","volume",-5]}' ;;
    '') _err "usage: m vol [0-100 | + | -]" ;;
    *)
      [[ "$1" =~ ^[0-9]+$ ]] || _err "usage: m vol [0-100 | + | -]"
      (( $1 > 150 )) && _err "max volume is 150"
      _silent "{\"command\":[\"set_property\",\"volume\",$1]}"
      ;;
  esac
  local v; v=$(_get volume)
  _info "volume: $(echo "$v" | awk '{printf "%.0f%%",$1}')"
}

do_seek() {
  _need
  [ -z "$1" ] && _err "usage: m seek [+N | -N | N | MM:SS]"
  local secs="$1"
  # Convert MM:SS â†’ seconds
  if echo "$1" | grep -qE '^[+-]?[0-9]+:[0-9]{2}$'; then
    local sign="" ts="$1"
    [[ "$1" == +* ]] && { sign="+"; ts="${1#+}"; }
    [[ "$1" == -* ]] && { sign="-"; ts="${1#-}"; }
    local m s
    m=$(echo "$ts" | cut -d: -f1)
    s=$(echo "$ts" | cut -d: -f2)
    secs="${sign}$(( m * 60 + s ))"
  fi
  case "$secs" in
    +*) _silent "{\"command\":[\"seek\",\"${secs#+}\",\"relative\"]}" ;;
    -*) _silent "{\"command\":[\"seek\",\"-${secs#-}\",\"relative\"]}" ;;
    *)  _silent "{\"command\":[\"seek\",\"$secs\",\"absolute\"]}" ;;
  esac
  local pos; pos=$(_get time-pos)
  local dur; dur=$(_get duration)
  pos=$(echo "$pos" | awk '{printf "%d:%02d",$1/60,$1%60}' 2>/dev/null)
  dur=$(echo "$dur" | awk '{printf "%d:%02d",$1/60,$1%60}' 2>/dev/null)
  _info "â© ${pos} / ${dur}"
}

do_speed() {
  _need
  case "$1" in
    +)  _silent '{"command":["multiply","speed",1.1]}' ;;
    -)  _silent '{"command":["multiply","speed",0.909]}' ;;
    r)  _silent '{"command":["set_property","speed",1.0]}'; _info "speed: 1.0x"; return ;;
    '')  _err "usage: m speed [0.25-4.0 | + | - | r]" ;;
    *)
      [[ "$1" =~ ^[0-9]+(\.[0-9]+)?$ ]] || _err "usage: m speed [0.25-4.0 | + | - | r]"
      _silent "{\"command\":[\"set_property\",\"speed\",$1]}"
      ;;
  esac
  local sp; sp=$(_get speed)
  _info "speed: $(echo "$sp" | awk '{printf "%.2fx",$1}')"
}

do_hp() {
  _need
  _silent '{"command":["set_property","audio-device","coreaudio/BuiltInHeadphoneOutputDevice"]}'
  _ok "ğŸ§ headphones"
}

do_sp() {
  _need
  _silent '{"command":["set_property","audio-device","coreaudio/BuiltInSpeakerDevice"]}'
  _ok "ğŸ”Š speakers"
}

do_shuffle() { _need; _silent '{"command":["playlist-shuffle"]}'; _ok "ğŸ”€ shuffled" }
do_repeat()  { _need; _silent '{"command":["cycle","loop-playlist"]}'; _info "ğŸ” repeat toggled" }
do_clear()   { _need; _silent '{"command":["playlist-clear"]}'; _ok "ğŸ—‘  queue cleared" }

do_now() {
  _need
  local title pos dur paused speed
  title=$(_get media-title)
  [ -z "$title" ] && { _warn "nothing playing"; return }
  pos=$(_get time-pos | awk '{printf "%d:%02d",$1/60,$1%60}' 2>/dev/null)
  dur=$(_get duration   | awk '{printf "%d:%02d",$1/60,$1%60}' 2>/dev/null)
  paused=$(_get pause)
  speed=$(_get speed | awk '{printf "%.2f",$1}')
  local icon="â–¶"; [ "$paused" = "true" ] && icon="â¸"
  echo ""
  echo "  ${icon}  ${Y}${title}${X}"
  echo "  ${W}${pos}${X} / ${W}${dur}${X}   speed: ${speed}x"
  echo ""
}

do_bar() {
  _need
  local title; title=$(_get media-title)
  [ -z "$title" ] && { _warn "nothing playing"; return }

  # Hide cursor, restore on exit
  tput civis
  trap 'tput cnorm; echo; return 0' INT TERM EXIT

  # Get terminal width, leave 2 chars margin
  local tw; tw=$(tput cols)
  local bar_w=$(( tw - 22 ))   # 22 = time stamps + brackets + padding
  (( bar_w < 10 )) && bar_w=10

  while true; do
    local pos dur paused speed title2
    pos=$(_get time-pos)
    dur=$(_get duration)
    paused=$(_get pause)
    speed=$(_get speed | awk '{printf "%.2f",$1}')
    title2=$(_get media-title)

    # If track changed or nothing playing, break
    [ -z "$pos" ] || [ -z "$dur" ] && break

    local pos_i dur_i
    pos_i=$(printf '%.0f' "$pos" 2>/dev/null || echo 0)
    dur_i=$(printf '%.0f' "$dur" 2>/dev/null || echo 1)
    (( dur_i < 1 )) && dur_i=1

    local pct=$(( pos_i * 100 / dur_i ))
    local filled=$(( pos_i * bar_w / dur_i ))
    local empty=$(( bar_w - filled ))
    (( filled < 0 )) && filled=0
    (( empty < 0 )) && empty=0

    local pos_fmt; pos_fmt=$(awk "BEGIN{printf \"%d:%02d\", $pos_i/60, $pos_i%60}")
    local dur_fmt; dur_fmt=$(awk "BEGIN{printf \"%d:%02d\", $dur_i/60, $dur_i%60}")
    local rem_i=$(( dur_i - pos_i ))
    local rem_fmt; rem_fmt=$(awk "BEGIN{printf \"-%d:%02d\", $rem_i/60, $rem_i%60}")

    local icon="â–¶"; [ "$paused" = "true" ] && icon="â¸"

    # Build bar: filled part cyan, empty part dark
    local bar_filled bar_empty bar_str
    bar_filled=$(printf '%*s' "$filled" '' | tr ' ' 'â”')
    bar_empty=$(printf '%*s' "$empty" '' | tr ' ' 'â”€')

    # Move to start of block (3 lines), clear each line
    printf '\r\e[2K'         # line 1: title
    printf "\e[0;36m  ${icon}  \e[1;37m%.${tw}s\e[0m" "$title2"
    printf '\n\r\e[2K'       # line 2: bar
    printf "  \e[0;36m%s\e[0m\e[2m%s\e[0m  \e[0;33m%s\e[0m / \e[0;37m%s\e[0m  \e[2m(%s)\e[0m" \
      "$bar_filled" "$bar_empty" "$pos_fmt" "$dur_fmt" "$rem_fmt"
    printf '\n\r\e[2K'       # line 3: meta
    printf "  \e[2mspeed: %sx   %d%%   q to quit\e[0m" "$speed" "$pct"

    # Move cursor back up 2 lines to overwrite next tick
    printf '\e[2A'

    # Non-blocking key read â€” q/Q/ESC exits
    local key
    if read -r -s -k1 -t 0.5 key 2>/dev/null; then
      [[ "$key" == 'q' || "$key" == 'Q' || "$key" == $'\e' ]] && break
      # p = toggle pause inline
      [[ "$key" == 'p' ]] && _silent '{"command":["cycle","pause"]}'
      # n/b = next/prev inline
      [[ "$key" == 'n' ]] && { _silent '{"command":["playlist-next"]}'; sleep 0.4; }
      [[ "$key" == 'b' ]] && { _silent '{"command":["playlist-prev"]}'; sleep 0.4; }
      # > / < = seek Â±10s inline
      [[ "$key" == '.' ]] && _silent '{"command":["seek","10","relative"]}'
      [[ "$key" == ',' ]] && _silent '{"command":["seek","-10","relative"]}'
      # + / - = volume
      [[ "$key" == '+' ]] && _silent '{"command":["add","volume",5]}'
      [[ "$key" == '-' ]] && _silent '{"command":["add","volume",-5]}'
    fi
  done

  # Clean up: move down past the 3 lines, restore cursor
  printf '\n\n\n'
  tput cnorm
  trap - INT TERM EXIT
}

do_scrub() {
  # Interactive seek scrubber â€” generates a timeline list in fzf,
  # user picks a timestamp to jump to. Works like a slider.
  _need
  local title pos dur
  title=$(_get media-title)
  [ -z "$title" ] && { _warn "nothing playing"; return }
  dur=$(_get duration)
  pos=$(_get time-pos)
  [ -z "$dur" ] && { _warn "duration unavailable (still buffering?)"; return }

  local dur_i; dur_i=$(printf '%.0f' "$dur")
  local pos_i; pos_i=$(printf '%.0f' "${pos:-0}")
  (( dur_i < 1 )) && { _warn "track too short to scrub"; return }

  # Build a list of timestamps â€” one per ~5 seconds, max 500 entries
  local step=5
  (( dur_i / step > 500 )) && step=$(( dur_i / 500 + 1 ))

  local lines=()
  local t=0
  while (( t <= dur_i )); do
    local mm ss pct bar_fill bar_empty filled_w empty_w
    mm=$(( t / 60 )); ss=$(( t % 60 ))
    pct=$(( t * 100 / dur_i ))
    filled_w=$(( pct * 30 / 100 ))
    empty_w=$(( 30 - filled_w ))
    bar_fill=$(printf '%*s' "$filled_w" '' | tr ' ' 'â–ˆ')
    bar_empty=$(printf '%*s' "$empty_w" '' | tr ' ' 'â–‘')
    # Mark current position
    local marker="  "
    (( t >= pos_i - step/2 && t <= pos_i + step/2 )) && marker="â–¶ "
    lines+=("$(printf '%s%02d:%02d  [%s%s]  %3d%%' "$marker" "$mm" "$ss" "$bar_fill" "$bar_empty" "$pct")")
    t=$(( t + step ))
  done

  local chosen
  chosen=$(printf '%s\n' "${lines[@]}" | "$FZF" \
    --height 70% --reverse \
    --prompt "â±  scrub > " \
    --header "â–¶ marks current pos Â· ENTER to jump Â· ESC cancel" \
    --no-sort)

  [ -z "$chosen" ] && { _warn "cancelled"; return }

  # Extract MM:SS from chosen line
  local ts; ts=$(echo "$chosen" | grep -oE '[0-9]+:[0-9]{2}' | head -1)
  [ -z "$ts" ] && { _err "could not parse timestamp"; }

  local m s target_secs
  m=$(echo "$ts" | cut -d: -f1 | sed 's/^0*//')
  s=$(echo "$ts" | cut -d: -f2 | sed 's/^0*//')
  m=${m:-0}; s=${s:-0}
  target_secs=$(( m * 60 + s ))

  _silent "{\"command\":[\"seek\",\"$target_secs\",\"absolute\"]}"
  sleep 0.1
  local new_pos; new_pos=$(_get time-pos | awk '{printf "%d:%02d",$1/60,$1%60}')
  _ok "jumped to ${new_pos}  /  $(awk "BEGIN{printf \"%d:%02d\",$dur_i/60,$dur_i%60}")"
}

do_queue() {
  _need
  local pl current_idx n
  pl=$(_cmd '{"command":["get_property","playlist"]}')
  n=$(echo "$pl" | "$JQ" '.data|length' 2>/dev/null)
  current_idx=$(_get playlist-playing-pos)
  [ -z "$n" ] || [ "$n" = "0" ] && { _warn "queue empty"; return }
  echo ""
  echo "  ${C}queue â€” ${n} tracks${X}"
  echo ""
  echo "$pl" | "$JQ" -r '.data[] | [(.id|tostring), (.title // .filename)] | @tsv' 2>/dev/null \
    | while IFS=$'\t' read -r id title; do
        if [ "$id" = "${current_idx}" ]; then
          echo "  ${G}â–¶ $((id+1)). ${title}${X}"
        else
          echo "    $((id+1)). ${title}"
        fi
      done
  echo ""
}

do_status() {
  if [ ! -S "$SOCKET" ]; then
    echo ""
    echo "  ${R}â— stopped${X}   run: m start"
    echo ""
    return
  fi
  local title paused vol speed
  title=$(_get media-title)
  paused=$(_get pause)
  vol=$(_get volume | awk '{printf "%.0f",$1}')
  speed=$(_get speed | awk '{printf "%.2f",$1}')
  echo ""
  echo "  ${G}â— running${X}   vol:${vol}%   speed:${speed}x"
  if [ -n "$title" ]; then
    local pos dur
    pos=$(_get time-pos | awk '{printf "%d:%02d",$1/60,$1%60}' 2>/dev/null)
    dur=$(_get duration   | awk '{printf "%d:%02d",$1/60,$1%60}' 2>/dev/null)
    [ "$paused" = "true" ] \
      && echo "  ${Y}â¸  ${title}${X}   ${pos}/${dur}" \
      || echo "  ${G}â–¶  ${title}${X}   ${pos}/${dur}"
  else
    echo "  ${W}idle â€” queue something with: m \"song name\"${X}"
  fi
  echo ""
}

# â”€â”€ like / love â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

do_like() {
  _need
  local title url clean
  title=$(_get media-title)
  url=$(_get path)
  [ -z "$url" ] && { _warn "nothing playing"; return }
  clean=$(_clean_url "$url")
  # Avoid duplicate likes
  if grep -qF "$clean" "$LIKES_FILE" 2>/dev/null; then
    _warn "already liked: $title"
    return
  fi
  printf '%s\t%s\t%s\n' "$(date '+%Y-%m-%d %H:%M')" "$title" "$clean" >> "$LIKES_FILE"
  _ok "â¤  liked: ${title}"
}

do_unlike() {
  [ -s "$LIKES_FILE" ] || { _warn "no likes yet"; return }
  local line
  line=$(cat "$LIKES_FILE" | "$FZF" \
    --height 50% --reverse \
    --prompt "ğŸ’” unlike > " \
    --header "ENTER to remove Â· ESC cancel" \
    --with-nth=2 --delimiter=$'\t')
  [ -z "$line" ] && { _warn "cancelled"; return }
  grep -vF "$line" "$LIKES_FILE" > "$LIKES_FILE.tmp" && mv "$LIKES_FILE.tmp" "$LIKES_FILE"
  _ok "removed from likes"
}

do_likes() {
  [ -s "$LIKES_FILE" ] || { _warn "no likes yet â€” use: m like"; return }
  echo ""
  echo "  ${M}â¤  liked tracks${X}"
  echo ""
  awk -F'\t' '{print NR". "$2}' "$LIKES_FILE" | sed 's/^/  /'
  echo ""
}

do_love() {
  # Play random liked track
  _need
  [ -s "$LIKES_FILE" ] || { _warn "no likes yet â€” use: m like while playing"; return }
  local url title
  local line; line=$(shuf -n1 "$LIKES_FILE")
  url=$(echo "$line" | awk -F'\t' '{print $3}')
  title=$(echo "$line" | awk -F'\t' '{print $2}')
  _start
  _silent '{"command":["playlist-clear"]}'
  _silent "{\"command\":[\"loadfile\",\"$url\",\"append-play\"]}"
  local actual_title; actual_title=$(_wait_prop media-title 30)
  _ok "â¤  â–¶  ${actual_title:-$title}"
}

do_likes_play() {
  # Interactive: pick a liked track to play
  _need
  [ -s "$LIKES_FILE" ] || { _warn "no likes yet"; return }
  local url title line
  line=$(cat "$LIKES_FILE" | "$FZF" \
    --height 50% --reverse \
    --prompt "â¤ play liked > " \
    --header "ENTER play Â· ESC cancel" \
    --with-nth=2 --delimiter=$'\t')
  [ -z "$line" ] && { _warn "cancelled"; return }
  url=$(echo "$line" | awk -F'\t' '{print $3}')
  _silent '{"command":["playlist-clear"]}'
  _silent "{\"command\":[\"loadfile\",\"$url\",\"append-play\"]}"
  local actual_title; actual_title=$(_wait_prop media-title 30)
  _ok "â–¶  ${actual_title:-playing}"
}

# â”€â”€ history â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

do_history() {
  [ -s "$HISTORY_FILE" ] || { _warn "no history yet"; return }
  local line url
  line=$(tac "$HISTORY_FILE" | "$FZF" \
    --height 60% --reverse \
    --prompt "ğŸ•‘ history > " \
    --header "ENTER replay Â· ESC cancel" \
    --with-nth=1,2 --delimiter=$'\t' \
    --preview 'echo "Date: "$(echo {} | cut -f1)"\nTitle: "$(echo {} | cut -f2)"\nURL: "$(echo {} | cut -f3)' \
    --preview-window=down:3:wrap)
  [ -z "$line" ] && { _warn "cancelled"; return }
  url=$(echo "$line" | awk -F'\t' '{print $3}')
  [ -z "$url" ] && { _err "could not extract URL from history entry"; }
  _start
  _silent '{"command":["playlist-clear"]}'
  _silent "{\"command\":[\"loadfile\",\"$url\",\"append-play\"]}"
  local title; title=$(_wait_prop media-title 30)
  _ok "â–¶  ${title:-playing}"
}

do_history_clear() {
  echo -n "${Y}Clear all history? [y/N] ${X}"
  read -r ans
  [[ "$ans" =~ ^[Yy]$ ]] || { _warn "cancelled"; return }
  > "$HISTORY_FILE"
  _ok "history cleared"
}

# â”€â”€ playlists â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

do_save() {
  _need
  [ -z "$1" ] && _err "usage: m save <name>"
  local name="$1"
  # Sanitize name
  name=$(echo "$name" | tr ' ' '_' | tr -cd '[:alnum:]_-')
  [ -z "$name" ] && _err "invalid playlist name"
  local file="$PLAYLIST_DIR/${name}.m3u"
  local count=0
  while IFS= read -r url; do
    [ -z "$url" ] && continue
    echo "$(_clean_url "$url")" >> "$file.tmp"
    count=$(( count + 1 ))
  done < <(_cmd '{"command":["get_property","playlist"]}' | "$JQ" -r '.data[].filename' 2>/dev/null)
  [ $count -eq 0 ] && { rm -f "$file.tmp"; _err "queue is empty â€” nothing to save"; }
  mv "$file.tmp" "$file"
  _ok "saved: ${name}  (${count} tracks)"
}

do_load() {
  [ -z "$1" ] && _err "usage: m load <name>"
  local f="$PLAYLIST_DIR/${1}.m3u"
  [ -f "$f" ] || _err "playlist not found: $1"
  _start
  _silent '{"command":["playlist-clear"]}'
  local count=0
  while IFS= read -r line; do
    [[ -z "$line" || "$line" == \#* ]] && continue
    _silent "{\"command\":[\"loadfile\",\"$line\",\"append-play\"]}"
    count=$(( count + 1 ))
  done < "$f"
  _ok "loaded: $1  (${count} tracks)"
  _info "first track buffering... use: m now"
}

do_playlists() {
  echo ""
  echo "  ${C}saved playlists:${X}"
  local found=0
  for f in "$PLAYLIST_DIR"/*.m3u(N); do
    local name; name=$(basename "$f" .m3u)
    local count; count=$(grep -c '.' "$f" 2>/dev/null || echo 0)
    echo "  âˆ™ ${name}  ${W}(${count} tracks)${X}"
    found=1
  done
  [ $found -eq 0 ] && echo "  (none yet â€” use: m save <name>)"
  echo ""
}

do_playlist_del() {
  [ -z "$1" ] && _err "usage: m pldel <name>"
  local f="$PLAYLIST_DIR/${1}.m3u"
  [ -f "$f" ] || _err "not found: $1"
  rm "$f"
  _ok "deleted playlist: $1"
}

# â”€â”€ cache management â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

do_cache_clear() {
  local count; count=$(ls "$CACHE_DIR"/*.cache 2>/dev/null | wc -l | tr -d ' ')
  rm -f "$CACHE_DIR"/*.cache
  _ok "cleared ${count} cached search(es)"
}

do_cache_stats() {
  local total expired fresh
  total=0; expired=0; fresh=0
  for f in "$CACHE_DIR"/*.cache(N); do
    total=$(( total + 1 ))
    if [ "$(_cache_age "$f")" -ge 3600 ]; then
      expired=$(( expired + 1 ))
    else
      fresh=$(( fresh + 1 ))
    fi
  done
  echo ""
  echo "  ${C}cache stats:${X}"
  echo "  total:   ${total}"
  echo "  fresh:   ${G}${fresh}${X}"
  echo "  expired: ${Y}${expired}${X}  (auto-refreshed on next use)"
  echo "  dir:     $CACHE_DIR"
  echo ""
}

# Prune only expired cache entries
do_cache_prune() {
  local count=0
  for f in "$CACHE_DIR"/*.cache(N); do
    if [ "$(_cache_age "$f")" -ge 3600 ]; then
      rm -f "$f"
      count=$(( count + 1 ))
    fi
  done
  _ok "pruned ${count} expired cache entrie(s)"
}

# â”€â”€ devices â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

do_devices() {
  echo ""
  echo "  ${C}audio devices:${X}"
  "$MPV" --audio-device=help 2>&1 | grep "'" | sed 's/^/  /'
  echo ""
  echo "  current: ${W}$(_get audio-device)${X}"
  echo ""
}

# â”€â”€ help â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

do_help() {
  cat <<EOF

  ${C}m â€” terminal music CLI${X}   (all data in ~/music_system/)

  ${W}PLAY${X}
    m "query"              search & play (fzf picker)
    m "query" -a           add to queue
    m "query" -hp          play via headphones
    m "query" -sp          play via speakers
    m "query" -a -hp       add + switch to headphones

  ${W}TRANSPORT${X}
    pause / pp             toggle pause
    next  / mn             next track
    prev  / mb             previous track
    seek +30               seek forward 30s
    seek -15               seek back 15s
    seek 1:30              jump to 1m30s
    seek 90                jump to 90s
    speed 1.5              set playback speed
    speed + / -            step speed up/down
    speed r                reset speed to 1x
    stop                   kill daemon
    start                  start daemon

  ${W}VOLUME & OUTPUT${X}
    vol 80                 set volume (0-150)
    vol + / -              step Â±5
    hp / headphones        switch to headphones
    sp / speakers          switch to speakers
    devices                list audio devices

  ${W}INFO${X}
    now                    current track + position (static)
    bar / progress         live progress bar (updates every 0.5s)
                             keys: p=pause  n=next  b=prev
                                   ,=âˆ’10s  .=+10s  +/âˆ’=vol  q=quit
    scrub / slider         interactive seek slider (fzf timeline)
    queue                  show queue (current track highlighted)
    status                 daemon status

  ${W}LIKES${X}
    like                   â¤ like current track
    unlike                 remove a liked track (fzf)
    likes                  list liked tracks
    likes-play             pick & play a liked track (fzf)
    love                   play random liked track

  ${W}HISTORY${X}
    history                fuzzy-search & replay history
    history-clear          wipe play history

  ${W}PLAYLISTS${X}
    save <name>            save current queue as playlist
    load <name>            load playlist into queue
    playlists / pls        list saved playlists
    pldel <name>           delete a playlist

  ${W}QUEUE${X}
    shuffle                shuffle queue
    repeat / rp            toggle repeat
    clear                  clear queue

  ${W}CACHE${X}
    cache-clear            remove all search caches
    cache-prune            remove only expired caches (>1hr)
    cache-stats            show cache info

EOF
}

# â”€â”€ main dispatch â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

[ $# -eq 0 ] && { do_status; exit 0 }

case "$1" in
  pause|pp)            do_pause;                  exit 0 ;;
  next|mn)             do_next;                   exit 0 ;;
  prev|mb)             do_prev;                   exit 0 ;;
  stop)                do_stop;                   exit 0 ;;
  start)               do_start;                  exit 0 ;;
  shuffle)             do_shuffle;                exit 0 ;;
  repeat|rp)           do_repeat;                 exit 0 ;;
  clear)               do_clear;                  exit 0 ;;
  now)                 do_now;                    exit 0 ;;
  bar|progress)        do_bar;                    exit 0 ;;
  scrub|slider)        do_scrub;                  exit 0 ;;
  queue)               do_queue;                  exit 0 ;;
  status)              do_status;                 exit 0 ;;
  hp|headphones)       do_hp;                     exit 0 ;;
  sp|speakers)         do_sp;                     exit 0 ;;
  devices)             do_devices;                exit 0 ;;
  playlists|pls)       do_playlists;              exit 0 ;;
  save)                do_save "$2";              exit 0 ;;
  load)                do_load "$2";              exit 0 ;;
  pldel)               do_playlist_del "$2";      exit 0 ;;
  vol|volume)          do_vol "$2";               exit 0 ;;
  seek)                do_seek "$2";              exit 0 ;;
  speed)               do_speed "$2";             exit 0 ;;
  like)                do_like;                   exit 0 ;;
  unlike)              do_unlike;                 exit 0 ;;
  likes)               do_likes;                  exit 0 ;;
  likes-play|lp)       do_likes_play;             exit 0 ;;
  love)                do_love;                   exit 0 ;;
  history|hist)        do_history;                exit 0 ;;
  history-clear)       do_history_clear;          exit 0 ;;
  cache-clear)         do_cache_clear;            exit 0 ;;
  cache-prune)         do_cache_prune;            exit 0 ;;
  cache-stats)         do_cache_stats;            exit 0 ;;
  help|-h|--help)      do_help;                   exit 0 ;;
esac

# Free-form query with optional flags
QUERY=""
FLAG_ADD=0
FLAG_HP=0
FLAG_SP=0

for arg in "$@"; do
  case "$arg" in
    -a|--add)          FLAG_ADD=1 ;;
    -hp|--headphones)  FLAG_HP=1 ;;
    -sp|--speakers)    FLAG_SP=1 ;;
    -*)                _err "unknown flag: $arg  (run: m help)" ;;
    *)                 QUERY="$QUERY $arg" ;;
  esac
done

QUERY="${QUERY## }"
[ -z "$QUERY" ] && _err "no query â€” usage: m \"song name\"  or  m help"

if [ $FLAG_ADD -eq 1 ]; then
  do_add "$QUERY"
else
  do_play "$QUERY"
fi

[ $FLAG_HP -eq 1 ] && sleep 0.4 && do_hp
[ $FLAG_SP -eq 1 ] && sleep 0.4 && do_sp
